{
    "collab_server" : "",
    "contents" : "\nevtree_ret <- function(formula, data.train, data.test,samp.method,tuneLength,subset,class.response, response,Metric){\n\nret <- list()\n\nif(class.response == \"numeric\" | class.response == \"integer\"){\n  return.matrix <- matrix(NA,1,7)\n  colnames(return.matrix) <- c(\"nodes\",\"nvar\",\"nsplits\",\"rmse.samp\",\n                               \"rsq.samp\",\"rmse.test\",\"rsq.test\")\n\n}else{\n  return.matrix <- matrix(NA,1,7)\n  colnames(return.matrix) <- c(\"nodes\",\"nvar\",\"nsplits\",\"auc.samp\",\n                               \"accuracy.samp\",\"auc.test\",\"accuracy.test\")\n\n}\n\nevtree.out <- evtree(formula,data.train)\n\n#if(inherits(train.out, \"try-error\")){\n#  return.matrix[1,] <- c(0,0,0,NA,NA,NA,NA)\n#  return.splits <- as.data.frame(matrix(NA,1,2))\n#  colnames(return.splits) <- c(\"var\",\"val\")\n#  return.splits[1,1] <- \"no split\"\n#  return.splits[1,2] <- 0\n#  return.splits[1,1] <- as.character(return.splits[1,1])\n#  return.splits[1,2] <- as.numeric(as.character(return.splits[1,2]))\n#  evtree.ret <- NA\n#  train.out <- NA\n\n#}else{\n\n#evtree.out <- train.out$finalModel\n\n#if(inherits(train.out, \"try-error\")){\n#  return.matrix <- NA\n#}else{\n\n\n\n#min.error <- which(min(cp[,\"xerror\"]) == cp[,\"xerror\"])[1]\nreturn.matrix[1,\"nsplits\"] <- max(fitted(evtree.out)[,1]) - length(unique(fitted(evtree.out)[,1]))\n#return.matrix[1,\"fit.cv\"] <- cp[min.error,\"xerror\"]\n\n\n\n#depth(evtree.out$node)\n\nret.obj <- as.list(evtree.out$node)\nlen <- length(ret.obj)\n\nvars <- rep(NA,len)\nfor(i in 1:len){\n\n  if(is.null(ret.obj[[i]]$split$varid)==FALSE){\n    vars[i] <- ret.obj[[i]]$split$varid\n  }else{\n    vars[i] <- NA\n  }\n}\n\n\n\nbreaks <- rep(NA,len)\nfor(i in 1:len){\n\n  if(is.null(ret.obj[[i]]$split$breaks)==FALSE){\n    breaks[i] <- ret.obj[[i]]$split$breaks\n  }else if(is.null(ret.obj[[i]]$split$index)==FALSE){\n    breaks[i] <- median(ret.obj[[i]]$split$index)\n  }else{\n    breaks[i] <- NA\n  }\n}\n\n\nreturn.splits <- list()\n\nif(return.matrix[1,\"nsplits\"] == 0 ){\n  return.splits <- as.data.frame(matrix(NA,1,2))\n  colnames(return.splits) <- c(\"var\",\"val\")\n  return.splits[1,1] <- \"no split\"\n  return.splits[1,2] <- 0\n  return.splits[1,1] <- as.character(return.splits[1,1])\n  return.splits[1,2] <- as.numeric(as.character(return.splits[1,2]))\n}else{\n  tt = terms(formula,data=data.train)\n  preds <- unlist(attr(tt,\"term.labels\"))\n\n  breaks2 <- breaks[complete.cases(breaks)]\n  vars2 <- vars[complete.cases(vars)]\n\n  return.splits <- data.frame(cbind(preds[vars2],breaks2))\n  colnames(return.splits) <- c(\"var\",\"val\")\n  return.splits[,2] <- as.numeric(as.character(return.splits[,2]))\n\n}\n\n\n\nvars2 <- vars[is.na(vars)==FALSE]\nvars3 <- length(unique(vars2))\n\nevtree.ret <- evtree.out\n#attributes(evtree.out)\n\n\nreturn.matrix[1,\"nvar\"] <- vars3\n\nreturn.matrix[1,\"nodes\"] <- length(unique(fitted(evtree.out)[,1]))\n\nmet1 <- rep(NA,20)\nmet2 <- rep(NA,20)\n\n  if(class.response == \"numeric\" | class.response == \"integer\"){\n    met1 <- sqrt(mean((data.train[,response] - predict(evtree.out))^2))\n    pp = predict(evtree.out)\n    if(sd(pp)==0) pp <- pp+rnorm(length(pp),0,.000001)\n    met2 <- (cor(data.train[,response],pp))**2\n  }else{\n    if(all(duplicated(data.train[,response])[-1L])){\n      met1 <- NA\n    }else{\n      met1 <- pROC::auc(data.train[,response],predict(evtree.out,type=\"prob\")[,1])\n    }\n    met2 <- caret::confusionMatrix(data.train[,response],predict(evtree.out))$overall[\"Accuracy\"]\n  }\n\n\n\n\n\n\n\nif(class.response == \"numeric\" | class.response == \"integer\"){\n  #which(train.out$results[,\"cp\"] == train.out$bestTune)\n\n  #return.matrix[1,\"rmse.samp\"] <- train.out$results[ind,\"RMSE\"]\n  return.matrix[1,\"rmse.samp\"] <- met1 #sqrt(mean((data.train[,response] - predict(ctreePrune.out))^2))\n  return.matrix[1,\"rsq.samp\"] <- met2 #(cor(data.train[,response],predict(ctreePrune.out)))**2\n  #return.matrix[1,\"rsq.samp\"] <- train.out$results[ind,\"Rsquared\"]\n\n  if(subset==FALSE){\n    return.matrix[1,\"rmse.test\"] <- NA\n    return.matrix[1,\"rsq.test\"] <- NA\n  }else{\n    return.matrix[1,\"rmse.test\"] <- sqrt(mean((data.test[,response] - predict(evtree.out,data.test))^2))\n    return.matrix[1,\"rsq.test\"] <- (cor(data.test[,response],predict(evtree,data.test)))**2\n  }\n}else{\n  return.matrix[1,\"auc.samp\"] <- met1#pROC::auc(data.train[,response],predict(ctreePrune.out,type=\"prob\")[,1])\n  return.matrix[1,\"accuracy.samp\"] <- met2#caret::confusionMatrix(data.train[,response],predict(ctreePrune.out))$overall[\"Accuracy\"]\n\n  if(subset==FALSE){\n    # return.matrix[1,\"auc.test\"] <- NA\n  }else{\n    #  return.matrix[1,\"auc.test\"] <- NA\n  }\n}\n\n#}\nret$return.splits <- return.splits\nret$firstSplit <- return.splits[1,]\nret$vec <- return.matrix\nret$evtree.ret <- evtree.ret\nreturn(ret)\n\n\n}\n",
    "created" : 1490983140924.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2312810336",
    "id" : "420771D6",
    "lastKnownWriteTime" : 1490987022,
    "last_content_update" : 1490987022,
    "path" : "~/GitHub/dtree/R/evtree_ret.R",
    "project_path" : "R/evtree_ret.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}