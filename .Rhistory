samp.method="cv",tuneLength=2,stablelearner=TRUE)
library(dtree)
ret <- stable(default ~ ., data=Default,methods=c("ctree"),
samp.method="cv",tuneLength=2,stablelearner=TRUE)
library(dtree)
ret <- stable(default ~ ., data=Default,methods=c("ctree"),
samp.method="cv",tuneLength=2,stablelearner=TRUE)
library(dtree)
library(dtree)
ret <- stable(default ~ ., data=Default,methods=c("ctree"),
samp.method="cv",tuneLength=2,stablelearner=TRUE)
library(dtree)
ret <- stable(default ~ ., data=Default,methods=c("ctree"),
samp.method="cv",tuneLength=2,stablelearner=TRUE)
?stabletree
library(dtree)
ret <- stable(default ~ ., data=Default,methods=c("ctree"),
samp.method="cv",tuneLength=2,stablelearner=TRUE)
library(dtree)
ret <- stable(default ~ ., data=Default,methods=c("ctree"),
samp.method="cv",tuneLength=2,stablelearner=TRUE)
library(dtree)
ret <- stable(default ~ ., data=Default,methods=c("ctree"),
samp.method="cv",tuneLength=2,stablelearner=TRUE)
ret <- stable(formula=default ~ ., data=Default,methods=c("ctree"),
samp.method="cv",tuneLength=2,stablelearner=TRUE)
formula=default ~ .
formula2 <- terms(formula,data=data)
data=Default
formula2 <- terms(formula,data=data)
ret <- stable(formula=default ~ ., data=Default,methods=c("ctree"),
samp.method="cv",tuneLength=2,stablelearner=TRUE)
rm(formula)
rm(formula2)
environment(stable) <- formula2
ret <- stable(default ~ ., data=Default,methods=c("ctree"),
samp.method="cv",tuneLength=2,stablelearner=TRUE)
library(dtree)
ret <- stable(default ~ ., data=Default,methods=c("ctree"),
samp.method="cv",tuneLength=2,stablelearner=TRUE)
library(dtree)
library(dtree)
ret <- stable(default ~ ., data=Default,methods=c("ctree"),
samp.method="cv",tuneLength=2,stablelearner=TRUE)
library(dtree)
ret <- stable(default ~ ., data=Default,methods=c("ctree"),
samp.method="cv",tuneLength=2,stablelearner=TRUE)
library(dtree)
library(dtree)
ret <- stable(default ~ ., data=Default,methods=c("ctree"),
samp.method="cv",tuneLength=2,stablelearner=TRUE)
library(dtree)
ret <- stable(default ~ ., data=Default,methods=c("ctree"),
samp.method="cv",tuneLength=2,stablelearner=TRUE)
library(dtree)
ret <- stable(default ~ ., data=Default,methods=c("ctree"),
samp.method="cv",tuneLength=2,stablelearner=TRUE)
library(dtree)
ret <- stable(default ~ ., data=Default,methods=c("ctree"),
samp.method="cv",tuneLength=2,stablelearner=TRUE)
tt = train(default ~ ., data=Default,method="ctree")
tree1 <- partykit::ctree(default ~ ., data=Default,
control=ctree_control(mincriterion=as.numeric(tt$bestTune)))
tree2 <- prune(tree1,cp=as.numeric(tt$bestTune))
ee = stabletree(tree1)
ee = stabletree(tree1)
library(dtree)
library(dtree)
ret <- stable(default ~ ., data=Default,methods=c("ctree"),
samp.method="cv",tuneLength=2,stablelearner=TRUE)
library(dtree)
ret <- stable(default ~ ., data=Default,methods=c("ctree"),
samp.method="cv",tuneLength=2,stablelearner=TRUE)
library(dtree)
ret <- stable(default ~ ., data=Default,methods=c("ctree"),
samp.method="cv",tuneLength=2,stablelearner=TRUE)
tt = train(default ~ ., data=Default,method="rpart")
tt$finalModel
tt = train(default ~ ., data=Default,method="rpart")
tt$finalModel
rpart.ret <- tt$finalModel
rpart.ret$frame[,"var"]
vars <- rpart.ret$frame[,"var"]
vars2 <- vars[vars != "<leaf>"]
length(unique(vars2))
length(vars[vars == "<leaf>"])
tt = train(default ~ ., data=Default,method="ctree")
rpart.ret <- tt$finalModel
ctree.ret <- tt$finalModel
vars <- ctree.ret$frame[,"var"]
ctree.ret
?ctree
where(ctree)
where(ctree.ret)
ctree.out <- tt$finalModel
nodes <- ctree.out@get_where()
nodes
str(ctree.out)
ctree.out@tree()
ctree.out@get_tree()
ctree.out@tree
str(ctree.out@tree)
ctree.out@tree$psplit$splitpoint
ctree.out@tree$psplit$variablename
ctree.out@tree$psplit$variableName
ctree.out@tree[[1]]
ctree.out@tree[[1]]psplit$splitpoint
ctree.out@tree[[1]]$psplit$splitpoint
str(ctree.out@tree[[1]])
tree.new <- ctree.out@tree$left
str(tree.new)
tree.new$psplit$splitpoint
tree.new$left
tree.new <- ctree.out@tree
seq(1,15,2)
mat <- data.frame(matrix(NA,15,2))
for(i in seq(1,15,2)){
mat[i,1] <-  tree.new$left$psplit$splitpoint
mat[i,2] <-  tree.new$left$psplit$variableName
mat[i+1,1] <-  tree.new$left$psplit$splitpoint
mat[i+1,2] <-  tree.new$left$psplit$variableName
tree.new <- tree.new$left
}
CtreePathFunc <- function (ct, data) {
ResulTable <- data.frame(Node = character(), Path = character())
for(Node in unique(where(ct))){
# Taking all possible non-Terminal nodes that are smaller than the selected terminal node
NonTerminalNodes <- setdiff(1:(Node - 1), unique(where(ct))[unique(where(ct)) < Node])
# Getting the weigths for that node
NodeWeights <- nodes(ct, Node)[[1]]$weights
# Finding the path
Path <- NULL
for (i in NonTerminalNodes){
if(any(NodeWeights & nodes(ct, i)[[1]][2][[1]] == 1)) Path <- append(Path, i)
}
# Finding the splitting creteria for that path
Path2 <- SB <- NULL
for(i in 1:length(Path)){
if(i == length(Path)) {
n <- nodes(ct, Node)[[1]]
} else {n <- nodes(ct, Path[i + 1])[[1]]}
if(all(data[which(as.logical(n$weights)), as.character(unlist(nodes(ct,Path[i])[[1]][[5]])[length(unlist(nodes(ct,Path[i])[[1]][[5]]))])] <= as.numeric(unlist(nodes(ct,Path[i])[[1]][[5]])[3]))){
SB <- "<="
} else {SB <- ">"}
Path2 <- paste(c(Path2, paste(as.character(unlist(nodes(ct,Path[i])[[1]][[5]])[length(unlist(nodes(ct,Path[i])[[1]][[5]]))]),
SB,
as.character(unlist(nodes(ct,Path[i])[[1]][[5]])[3]))),
collapse = ", ")
}
# Output
ResulTable <- rbind(ResulTable, cbind(Node = Node, Path = Path2))
}
return(ResulTable)
}
CtreePathFunc(ctree.out)
CtreePathFunc(ctree.out,Default)
partykit:::.list.rules.party(ctree.out)
str(CtreePathFunc(ctree.out,Default))
yy = CtreePathFunc(ctree.out,Default)
levels(yy$Path)
yy$Path
unique(yy$Path)
trim <- function (x) gsub("^\\s+|\\s+$", "", x)
getVariable <- function (x) sub("(.*?)[[:space:]].*", "\\1", x)
getSimbolo <- function (x) sub("(.*?)[[:space:]](.*?)[[:space:]].*", "\\2", x)
getReglaFinal = function(elemento) {
x = as.data.frame(strsplit(as.character(elemento),";"))
Regla = apply(x,1, trim)
Regla = data.frame(Regla)
indice = as.numeric(rownames(Regla))
variable = apply(Regla,1, getVariable)
simbolo = apply(Regla,1, getSimbolo)
ReglaRaw = data.frame(Regla,indice,variable,simbolo)
cols <- c( 'variable' , 'simbolo' )
ReglaRaw$tipo_corte <- apply(  ReglaRaw[ , cols ] ,1 , paste , collapse = "" )
#print(ReglaRaw)
cortes = unique(ReglaRaw$tipo_corte)
#print(cortes)
ReglaFinal = ""
for(i in 1:length(cortes)){
#print("------------------------------------")
#print(cortes[i])
#print("ReglaRaw econtrada")
#print(ReglaRaw$indice[ReglaRaw$tipo_corte==cortes[i]])
maximo = max(ReglaRaw$indice[ReglaRaw$tipo_corte==cortes[i]])
#print(maximo)
tmp = as.character(ReglaRaw$Regla[ReglaRaw$indice==maximo])
if(ReglaFinal==""){
ReglaFinal = tmp
}else{
ReglaFinal = paste(ReglaFinal,tmp,sep="; ",collapse="; ")
}
}
return(ReglaFinal)
}#getReglaFinal
CtreePathFuncAllCat <- function (ct) {
ResulTable <- data.frame(Node = character(), Path = character())
for(Node in unique(where(ct))){
# Taking all possible non-Terminal nodes that are smaller than the selected terminal node
NonTerminalNodes <- setdiff(1:(Node - 1), unique(where(ct))[unique(where(ct)) < Node])
# Getting the weigths for that node
NodeWeights <- nodes(ct, Node)[[1]]$weights
# Finding the path
Path <- NULL
for (i in NonTerminalNodes){
if(any(NodeWeights & nodes(ct, i)[[1]][2][[1]] == 1)) Path <- append(Path, i)
}
# Finding the splitting creteria for that path
Path2 <- SB <- NULL
variablesNombres <- array()
variablesPuntos <- list()
for(i in 1:length(Path)){
n <- nodes(ct, Path[i])[[1]]
if(i == length(Path)) {
nextNodeID = Node
} else {
nextNodeID = Path[i+1]
}
vec_puntos  = as.vector(n[[5]]$splitpoint)
vec_nombre  = n[[5]]$variableName
vec_niveles = attr(n[[5]]$splitpoint,"levels")
index = 0
if((length(vec_puntos)!=length(vec_niveles)) && (length(vec_niveles)!=0) ){
index = vec_puntos
vec_puntos = vector(length=length(vec_niveles))
vec_puntos[index] = TRUE
}
if(length(vec_niveles)==0){
index = vec_puntos
vec_puntos = n[[5]]$splitpoint
}
if(index==0){
if(nextNodeID==n$right$nodeID){
vec_puntos = !vec_puntos
}else{
vec_puntos = !!vec_puntos
}
if(i != 1) {
for(j in 1:(length(Path)-1)){
if(length(variablesNombres)>=j){
if( variablesNombres[j]==vec_nombre){
vec_puntos = vec_puntos*variablesPuntos[[j]]
}
}
}
vec_puntos = vec_puntos==1
}
SB = "="
}else{
if(nextNodeID==n$right$nodeID){
SB = ">"
}else{
SB = "<="
}
}
variablesPuntos[[i]] = vec_puntos
variablesNombres[i] = vec_nombre
if(length(vec_niveles)==0){
descripcion = vec_puntos
}else{
descripcion = paste(vec_niveles[vec_puntos],collapse=", ")
}
Path2 <- paste(c(Path2, paste(c(variablesNombres[i],SB,"{",descripcion, "}"),collapse=" ")
),
collapse = "; ")
}
# Output
ResulTable <- rbind(ResulTable, cbind(Node = Node, Path = Path2))
}
we = weights(ct)
c0 = as.matrix(where(ct))
c3 = sapply(we, function(w) sum(w))
c3 = as.matrix(unique(cbind(c0,c3)))
Counts = as.matrix(c3[,2])
c2 = drop(Predict(ct))
Means = as.matrix(unique(c2))
ResulTable = data.frame(ResulTable,Means,Counts)
ResulTable  = ResulTable[ order(ResulTable$Means) ,]
ResulTable$TruePath =  apply(as.data.frame(ResulTable$Path),1, getReglaFinal)
ResulTable2 = ResulTable
ResulTable2$SQL <- paste("WHEN ",gsub("\\'([-+]?([0-9]*\\.[0-9]+|[0-9]+))\\'", "\\1",gsub("\\, ", "','", gsub(" \\}", "')", gsub("\\{ ", "('", gsub("\\;", " AND ", ResulTable2$TruePath)))))," THEN ")
cols <- c( 'SQL' , 'Node' )
ResulTable2$SQL <- apply(  ResulTable2[ , cols ] ,1 , paste , collapse = "'Nodo " )
ResulTable2$SQL <- gsub("THEN'", "THEN '", gsub(" '", "'",  paste(ResulTable2$SQL,"'")))
ResultadoFinal = list()
ResultadoFinal$PreTable = ResulTable
ResultadoFinal$Table = ResulTable
ResultadoFinal$Table$Path = ResultadoFinal$Table$TruePath
ResultadoFinal$Table$TruePath = NULL
ResultadoFinal$SQL = paste(" CASE ",paste(ResulTable2$SQL,sep="",collapse=" ")," END ",collapse="")
return(ResultadoFinal)
}#CtreePathFuncAllCat
CtreePathFuncAllCat(ctree.out)
install.packages("rpart.utils")
tt = train(default ~ ., data=Default,method="rpart")
library(rpart.utils)
rpart.rules.table(tt$finalModel)
tt
tt = rpart(default ~ ., data=Default)
tt
rpart.rules.table(tt$finalModel)
rpart.rules.table(tt)
rpart.subrules.table(tt)
library(ISLR)
tt = rpart(default ~ ., data=Default)
rpart.subrules.table(tt)
tt = evtree(default ~ ., data=Default)
CtreePathFuncAllCat(tt)
yy = CtreePathFunc(tt,Default)
library(xtable)
xtable(tt)
tt
tt = ctree(default ~ ., data=Default)
yy = CtreePathFunc(tt,Default)
tt
CtreePathFuncAllCat(tt)
tt = train(default ~ ., data=Default,method="ctree")$finalModel
yy = CtreePathFunc(tt,Default)
yy
unique(yy$Path)
CtreePathFuncAllCat(tt)
tt = train(default ~ ., data=Default,method="ctree")$finalModel
ctree.out <- tt$finalModel
(yy = CtreePathFunc(tt,Default))
yy[,2]
levels(yy)
levels(yy[,2])
unique(yy[,2])
unique(levels(yy[,2]))
ii = levels(yy[,2])[1]
gsub("(\\w+);\\1", "\\1", ii)
unique(unlist(strsplit(ii, ",")))
unique(unlist(strsplit(yy[,2], ",")))
yy
for(i in 1:nrow(yy)){
pp <- list()
pp <- c(pp,unique(unlist(strsplit(yy[i,2], ","))))
}
i
unique(unlist(strsplit(yy[i,2], ",")))
for(i in 1:nrow(yy)){
pp <- list()
pp <- c(pp,unique(unlist(strsplit(levels(yy[i,2]), ","))))
}
pp
length(pp)
matt <- matrix(NA,length(pp),2)
pp[[1]]
strsplit(pp[[1]]," ")
matt <- matrix(NA,length(pp),2)
for(j in 1:length(pp)){
rr <- strsplit(pp[[1]]," ")
matt[i,1] <- rr[1]
matt[i,2] <- rr[3]
}
rr
rr[[1]][1]
matt <- matrix(NA,length(pp),2)
for(j in 1:length(pp)){
rr <- strsplit(pp[[1]]," ")
matt[i,1] <- rr[[1]][1]
matt[i,2] <- as.numeric(rr[[1]][3])
}
matt
matt <- matrix(NA,length(pp),2)
for(j in 1:length(pp)){
rr <- strsplit(pp[[1]]," ")
matt[j,1] <- rr[[1]][1]
matt[j,2] <- as.numeric(rr[[1]][3])
}
matt
matt <- matrix(NA,length(pp),2)
for(j in 1:length(pp)){
rr <- strsplit(pp[[j]]," ")
matt[j,1] <- rr[[1]][1]
matt[j,2] <- as.numeric(rr[[1]][3])
}
matt
matt <- matrix(NA,length(pp),2)
for(j in 1:length(pp)){
rr <- strsplit(pp[[j]]," ")
matt[j,1] <- rr[[1]][1]
matt[j,2] <- rr[[1]][3]
}
matt
pp
min(rr[[1]])
rr
rr[[1]][1]
j
j=3
rr <- strsplit(pp[[j]]," ")
rr[[1]][1]
rr <- strsplit(pp[[j]],">" | "<=")
?strsplit
rr <- strsplit(pp[[j]],c(">","<="))
rr
matt <- matrix(NA,length(pp),2)
for(j in 1:length(pp)){
rr <- strsplit(pp[[j]],c(">","<="))
matt[j,1] <- rr[[1]][1]
matt[j,2] <- rr[[1]][2]
}
matt
rr <- strsplit(pp[[j]],collapse="")
rr <- strsplit(pp[[j]],collapse=" ")
collapse(pp[[j]],"")
paste(pp[[j]],collapse= )
paste(pp[[j]],collapse= "")
paste(pp[[j]],collapse= " ")
pp
j=4
rr <- strsplit(pp[[j]],collapse=" ")
pp
j=3
rr <- strsplit(pp[[j]],collapse=" ")
paste(pp[[j]],collapse= " ")
rr <- strsplit(pp[[j]],"\\, |\\,|" )
rr
rr <- strsplit(pp[[j]],">" )
rr
pp
j
j=2
rr <- strsplit(pp[[j]],">" )
rr
rr <- strsplit(pp[[j]],">, <=" )
rr
rr <- strsplit(pp[[j]],"> <=" )
rr
rr <- strsplit(pp[[j]],"[> <= ]+" )
rr
rr <- strsplit(pp[[j]],"[>, <= ]+" )
rr
jj
rr <- strsplit(pp[[j]],"[> <= ]" )
rr
rr <- strsplit(pp[[j]],"[> <= ]" )
rr!=""
rr[[1]]!=""
rr2 <- rr[[1]][rr[[1]]!=""]
matt <- matrix(NA,length(pp),2)
for(j in 1:length(pp)){
rr <- strsplit(pp[[j]],"[> <= ]" )
rr2 <- rr[[1]][rr[[1]]!=""]
matt[j,1] <- rr2[1]
matt[j,2] <- rr2[2]
}
matt
rpart.subrules.table(tt)
tt = train(default ~ ., data=Default,method="rpart")$finalModel
library(rpart.utils)
rpart.subrules.table(tt)
tt
tt = train(default ~ ., data=Default,method="rpart")$finalModel
library(rpart.utils)
rpart.subrules.table(tt)
tt
data(Default)
tt = train(default ~ ., data=Default,method="rpart")$finalModel
library(rpart.utils)
rpart.subrules.table(tt)
tt = train(default ~ ., data=Default,method="evtree")$finalModel
Default=Default[1:200,]
tt = train(default ~ ., data=Default,method="evtree")$finalModel
(yy = CtreePathFunc(tt,Default))
for(i in 1:nrow(yy)){
pp <- list()
pp <- c(pp,unique(unlist(strsplit(levels(yy[i,2]), ","))))
}
matt <- matrix(NA,length(pp),2)
for(j in 1:length(pp)){
rr <- strsplit(pp[[j]],"[> <= ]" )
rr2 <- rr[[1]][rr[[1]]!=""]
matt[j,1] <- rr2[1]
matt[j,2] <- rr2[2]
}
tt
str(tt)
where(tt)
length(unique(fitted(tt)[,1]))
nodes(tt)
nodes(tt,1)
nodeids(tt)
ttt <- as.party(tt)
nodeapply(tt)
as.partynode(tt)
as.partynode(nodeapply(tt))
node_inner(tt)
node_inner(tt)
partynode(tt)
as.partynode(tt)
nodeapply(tt)
as.party(tt)
tt
str(tt)
as.partykit(tt)
table(tt)
depth(tt)
plot(tt)
partykit:::.list.rules.party(tt)
Default=Default[1:600,]
tt = train(default ~ ., data=Default,method="evtree",tuneLength=1)$finalModel
data(Default)
Default=Default[1:600,]
tt = train(default ~ ., data=Default,method="evtree",tuneLength=2)$finalModel
data(Default)
Default=Default[1:1000,]
tt = train(default ~ ., data=Default,method="evtree",tuneLength=1)$finalModel
rpart.subrules.table(tt)
partykit:::.list.rules.party(tt)
str(partykit:::.list.rules.party(tt))
