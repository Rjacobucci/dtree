{
    "collab_server" : "",
    "contents" : "\n\n############################################################\n### Function to grow a tree using ctree\n### and pruning it using FDR\n###\n### qstar: numeric: level at which FDR must be controled\n###\n### size: numeric (0,1) the closer to 1 the bigger the tree\n###\n############################################################\n\n\nctreePrune <- function(formula,data,qstar=0.05,sizeSatu=0.999)  {\n\n  #argum<-list(formula=medv~., data=Boston)\n  #argum <- list()\n  #####################################################\n  #####   changes parameters to grow a very large tree\n  #####################################################\n  ctrl <- ctree_control(mincriterion=1-sizeSatu)\n\n  #############################\n  ### Grows a very large tree\n  #############################\n  #satTree <- do.call(partykit::ctree,argum)\n\n  satTree <- partykit::ctree(formula=formula, data=data,control=ctrl)\n\n\n  ############################################################\n  #####  Collect relevant information about the saturated tree\n  #############################################################\n  satTreeInfo <- DFtreeInfo(satTree)\n\n\n  ##############################\n  ### Prune the saturated tree\n  ##############################\n  temp <- fdrprune(satTree,qstar)\n  pruTree <- temp$tree\n\n  ############################################################\n  #####  Collect relevant information about the pruned tree\n  #############################################################\n  pruTreeInfo <- temp$info\n\n\n  list(tree=pruTree,\n       info=pruTreeInfo,\n       qstar=qstar,\n       sizeSatu=sizeSatu,\n       pvalue=temp$pvalue\n  )\n}\n\n#################################################\n###\n### Function to obtain a pruned tree using FDR\n###\n### fit: object of class party\n###\n#################################################\nfdrprune <- function(fit,qstar=0.05){\n\n  ###################################################\n  #####  Collect relevant information about the tree\n  ###################################################\n  datNo<-DFtreeInfo(fit)\n\n\n  ############################################\n  #####  Select the nodes to prune starting\n  #####   from the bottom\n  ############################################\n\n\n  ############################\n  #### List of terminal nodes\n  ############################\n  TNlist <- nodeids(fit,terminal=TRUE)\n\n  ############################\n  #### List of non-terminal nodes\n  ############################\n  wher <- nodeids(fit)%in%TNlist\n  nonTNlist <- nodeids(fit)[!wher]\n\n\n  ##############################\n  ####  Calculate pvalue for FDR\n  ##############################\n  pval<-datNo$pvalue\n  pval<-pval[!is.na(pval)]\n  pval<-sort(pval)\n\n  m<-length(pval)\n\n  qstar<-qstar #### FDR is controlled at qstar*100%\n\n  i<-1:m\n\n  temp <- (i/m)*qstar\n  k<-sum(pval <= temp )\n  if (!k==0) pvalue<-temp[k] else pvalue<-0\n\n  #######################################\n  #### New alpha to declare significance\n  #######################################\n  alpha<-pvalue\n\n\n\n  ######################################\n  #####  Identifies what nodes contain\n  #####  FDR corrected significant\n  #####  p-values\n  ######################################\n  datNo$FDRsigYN<-datNo$pvalue <= alpha & !is.na(datNo$pvalue)\n  wher <- is.na(datNo$pvalue)\n  datNo$FDRsigYN[wher]<-NA\n\n\n\n  ####################################\n  #### Identifies what nodes to prune\n  ####################################\n  #### loop over all terminal nodes\n  for (i in TNlist) {\n    j<-i\n    #### repeat while parent pvalue is not significant\n    while ( (is.na(datNo$pvalue[j]) | datNo$pvalue[j] > alpha) & !datNo$node[j]==1 ) {\n      datNo$pruneYN[j]<-TRUE\n      j <- datNo$parent[j]\n    }\n\n  }\n\n\n\n  ############################################################\n  ##### Make sure that all the nodes above a significant node\n  #####   are non terminal\n  ############################################################\n  #### List of nodes with significant pvalues\n  nonTNlist<-datNo$node [ !datNo$pruneYN ]\n\n  #### loop over all terminal nodes\n  for (i in nonTNlist) {\n    j<-i\n    #### repeat while parent pvalue is not significant\n    while ( !datNo$node[j]==1 ) {\n      datNo$pruneYN[j]<-FALSE\n      j <- datNo$parent[j]\n    }\n  }\n\n\n  ##########################################\n  #### If all the nodes have to be pruned\n  #### except root node, but root node is\n  #### not significant then prune also root\n  ##########################################\n  wher <- datNo$node==1\n  if (dim(datNo)[1]==1) {\n    datNo$pruneYN[wher]<-TRUE\n  } else if ( all(datNo$pruneYN[!wher]) & datNo$pvalue[wher]> alpha ) {\n    datNo$pruneYN[wher]<-TRUE\n  }\n\n\n  ########################\n  #####  prune the tree\n  ########################\n  nodesPru<-datNo$node[datNo$pruneYN]\n  out <- nodeprune(fit,nodesPru)\n\n  list(tree=out,info=datNo,pvalue=alpha)\n\n}\n\n##############################################################################\n### This function collect information about nodes for trees grown using Ctree\n##############################################################################\nDFtreeInfo<-function(fit) {\n\n  ############################################\n  ### Calculates IDs and left and right nodes\n  ############################################\n  #library(partykit)\n  nid <- nodeids(fit)\n  datNo <- nodeapply(fit, ids=nid, function(n) {\n    #\n    if (is.null(kids_node(n))) {\n      out <- data.frame(node= nodeids(n)[1],\n                        left=NA,\n                        right=NA)\n    }\n    if (!is.null(kids_node(n))) {\n      out <- data.frame(node= nodeids(n)[1],\n                        left=nodeids(kids_node(n)[[1]])[1],\n                        right=nodeids(kids_node(n)[[2]])[1])\n    }\n    out\n  })\n  datNo <- do.call(\"rbind\",datNo)\n\n\n\n  #########################################\n  ### Calculates the name of the covariates\n  ### used in each split\n  #########################################\n  datNo$varName <- NA\n\n  if (!length(fit)==0) {\n    tmpNames <- names(data_party(fit))\n    temp<-nodeapply(fit,nid, FUN = function(n) {\n      tmp <- n$split$varid\n      tmpNames[tmp]\n    })\n    temp<-unlist(temp)\n    wher <- datNo$node %in% as.numeric(names(temp))\n    datNo$varName[wher]<-temp\n  }\n\n\n\n  ###############################\n  ### extract pvalues from nodes\n  ###############################\n\n  if (!dim(datNo)[1]==1) {\n    temp<-nodeapply(fit, ids = nodeids(fit), function(n) info_node(n)$p.value)\n    pvalues<-sapply(1:length(temp),function(i){\n      if (is.null(temp[[i]])) out<-NA else out<-as.numeric(temp[[i]])\n    })\n    datNo$pvalue<-pvalues\n  }\n\n  if (dim(datNo)[1]==1) {\n    datNo$pvalue<-NA\n  }\n\n\n  ###############################\n  ### Defines terminal nodes\n  ###############################\n  temp<-nodeids(fit,terminal=TRUE)\n  wher <- datNo$node %in% temp\n  datNo$terminal[wher]<-TRUE\n  datNo$terminal[!wher]<-FALSE\n\n\n  ###############################\n  ### Defines pruneYN column\n  ###############################\n  datNo$pruneYN<-FALSE\n\n\n  ###############################\n  ### Defines FDRsigYN column\n  ###############################\n  datNo$FDRsigYN<-NA\n\n\n  ##########################################\n  #### Calculates identity of parent nodes\n  ##########################################\n  datNo$parent<-NA\n  for (i in datNo$node) {\n    tmpil<-datNo$left[i]\n    tmpir<-datNo$right[i]\n    datNo$parent[tmpil]<-i\n    datNo$parent[tmpir]<-i\n  }\n\n\n\n  datNo\n\n}\n",
    "created" : 1490655742809.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "136068801",
    "id" : "4ADDD65B",
    "lastKnownWriteTime" : 1490654061,
    "last_content_update" : 1490654061,
    "path" : "~/GitHub/dtree/R/ctreePrune.R",
    "project_path" : "R/ctreePrune.R",
    "properties" : {
    },
    "relative_order" : 13,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}