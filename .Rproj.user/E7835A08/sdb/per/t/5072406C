{
    "collab_server" : "",
    "contents" : ".make_formatinfo_simpleparty <- function(x, digits = getOption(\"digits\") - 4, sep = \"\")\n{\n  ## digit processing\n  digits <- max(c(0, digits))\n  digits2 <- max(c(0, digits - 2))\n\n  ## type of predictions\n  y <- node_party(x)$info$prediction\n  yclass <- class(y)[1]\n  if(yclass == \"ordered\") yclass <- \"factor\"\n  if(!(yclass %in% c(\"survfit\", \"factor\"))) yclass <- \"numeric\"\n\n  ## type of weights\n  n <- node_party(x)$info$n\n  if(is.null(names(n))) {\n    wdigits <- 0\n    wsym <- \"n\"\n  } else {\n    if(names(n) == \"w\") {\n      wdigits <- max(c(0, digits - 2))\n      wsym <- \"w\"\n    } else {\n      wdigits <- 0\n      wsym <- \"n\"\n    }\n  }\n\n  ## compute terminal node labels\n  FUN <- function(info) {\n    yhat <- info$prediction\n    if (yclass == \"survfit\") {\n        yhat <- .median_survival_time(yhat)\n        yclass <- \"numeric\"\n    }\n    if(yclass == \"numeric\") yhat <- format(round(yhat, digits = digits), nsmall = digits)\n    w <- info$n\n    yerr <- if(is.null(info$error)) \"\" else paste(\", err = \",\n      format(round(info$error, digits = digits2), nsmall = digits2),\n      names(info$error), sep = \"\")\n    rval <- paste(yhat, sep,\n      \" (\", wsym, \" = \", format(round(w, digits = wdigits), nsmall = wdigits),\n      yerr, \")\", sep = \"\")\n    unlist(strsplit(rval, \"\\n\"))\n  }\n  return(FUN)\n}\n\nplot.simpleparty <- function(x, digits = getOption(\"digits\") - 4, tp_args = NULL, ...) {\n  if(is.null(tp_args)) tp_args <- list(FUN = .make_formatinfo_simpleparty(x, digits = digits, sep = \"\\n\"))\n  plot.party(x, tp_args = tp_args, ...)\n}\n\nprint.simpleparty <- function(x, digits = getOption(\"digits\") - 4,\n  header = NULL, footer = TRUE, ...)\n{\n  ## header panel\n  if(is.null(header)) header <- !is.null(terms(x))\n  header_panel <- if(header) function(party) {\n    c(\"\", \"Model formula:\", deparse(formula(terms(party))), \"\", \"Fitted party:\", \"\")\n  } else function(party) \"\"\n  \n  ## footer panel\n  footer_panel <- if(footer) function(party) {\n    n <- width(party)\n    n <- format(c(length(party) - n, n))\n    \n    c(\"\", paste(\"Number of inner nodes:   \", n[1]),\n      paste(\"Number of terminal nodes:\", n[2]), \"\")\n  } else function (party) \"\"\n\n  ## terminal panel\n  terminal_panel <- function(node) formatinfo_node(node,\n    FUN = .make_formatinfo_simpleparty(x, digits = digits),\n    default = \"*\", prefix = \": \")\n\n  print.party(x, terminal_panel = terminal_panel,\n    header_panel = header_panel, footer_panel = footer_panel, ...)\n}\n\npredict_party.simpleparty <- function(party, id, newdata = NULL,\n    type = c(\"response\", \"prob\", \"node\"), ...)\n{\n  ## get observation names: either node names or\n  ## observation names from newdata\n  nam <- if(is.null(newdata)) names(party)[id] else rownames(newdata)\n  if(length(nam) != length(id)) nam <- NULL\n\n  ## match type\n  type <- match.arg(type)\n\n  ## special case: fitted ids\n  if(type == \"node\") return(structure(id, .Names = nam))\n\n  ## predictions\n  if(type == \"response\") {\n    FUN <- function(x) x$info$prediction\n  } else {\n    if(is.null(node_party(party)$info$distribution)) stop(\"probabilities not available\")\n    scale <- any(node_party(party)$info$distribution > 1)\n    FUN <- function(x) if(scale) prop.table(x$info$distribution) else x$info$distribution\n  }\n  predict_party.default(party, id, nam, FUN = FUN, ...)\n}\n\nas.simpleparty <- function(obj, ...) UseMethod(\"as.simpleparty\")\n\nas.simpleparty.simpleparty <- function(obj, ...) obj\n\nas.simpleparty.party <- function(obj, ...) {\n  if (is.simpleparty(obj)) {\n      class(obj) <- unique(c(\"simpleparty\", class(obj)))\n      return(obj)\n  }\n  if (is.constparty(obj)) \n      return(as.simpleparty(as.constparty(obj)))\n  stop(\"cannot coerce objects of class \", sQuote(class(obj)), \n       \" to class \", sQuote(\"simpleparty\"))\n}\n\nas.simpleparty.XMLNode <- function(obj, ...) as.party(obj)\n\nas.simpleparty.constparty <- function(obj, ...) {\n  ## extract and delete fitted\n  fit <- obj$fitted\n  obj$fitted <- NULL\n\n  ## response info\n  rtype <- class(fit[[\"(response)\"]])[1]\n  if (rtype == \"ordered\") rtype <- \"factor\"    \n  if (rtype == \"integer\") rtype <- \"numeric\"\n\n  ## extract fitted info\n  FUN <- function(node, fitted) {\n    fitted <- subset(fitted,\n      fitted[[\"(fitted)\"]] %in% nodeids(node, terminal = TRUE))\n\n    if (nrow(fitted) == 0)\n      return(list(prediction = NA, n = 0,\n                  error = NA, distribution = NULL))\n\n    y <- fitted[[\"(response)\"]]\n    w <- fitted[[\"(weights)\"]]\n    if(is.null(w)) {\n      w <- rep(1, nrow(fitted))\n      wnam <- \"n\"\n    } else {\n      wnam <- if(isTRUE(all.equal(w, round(w)))) \"n\" else \"w\" \n    }\n    \n    ## extract p.value (if any)\n    pval <- function(node) {\n      p <- info_node(node)\n      if(is.list(p)) p$p.value else NULL\n    }\n    \n    switch(rtype,\n      \"numeric\" = {\n        yhat <- .pred_numeric_response(y, w)\n        list(prediction = yhat, n = structure(sum(w), .Names = wnam),\n\t  error = sum(w * (y - yhat)^2), distribution = NULL, p.value = pval(node))\n      },\n      \"factor\" = {\n        yhat <- .pred_factor_response(y, w)\n        ytab <- round(.pred_factor(y, w) * sum(w))\n        list(prediction = yhat, n = structure(sum(w), .Names = wnam),\n\t  error = structure(sum(100 * prop.table(ytab)[names(ytab) != yhat]), .Names = \"%\"),\n\t  distribution = ytab, p.value = pval(node))\n      },\n      \"Surv\" = {\n        list(prediction = .pred_Surv(y, w), n = structure(sum(w), .Names = wnam),\n\t  error = NULL, distribution = NULL, p.value = pval(node)) ## FIXME: change distribution format?\n      })\n  }\n\n  ## convenience function for computing kid ids\n  fit2id <- function(fit, idlist) {\n    fit <- factor(fit)\n    nlevels <- levels(fit)\n    for(i in 1:length(idlist)) nlevels[match(idlist[[i]], levels(fit))] <- i\n    levels(fit) <- nlevels\n    ret <- factor(as.numeric(as.character(fit)), labels = 1:length(idlist), levels = 1:length(idlist))\n    ret\n  }\n\n  ## cycle through node\n  new_node <- function(onode, fitted) {\n    if(is.terminal(onode)) return(partynode(id = onode$id,\n      split = NULL, kids = NULL, surrogates = NULL,\n      info = FUN(onode, fitted)))\n    kids <- kids_node(onode)\n    kids_tid <- lapply(kids, nodeids, terminal = TRUE)\n    kids_fitted <- base::split.data.frame(fitted, fit2id(fitted[[\"(fitted)\"]], kids_tid), drop = FALSE)\n    partynode(id = onode$id, split = onode$split,\n      kids = lapply(1:length(kids), function(i) new_node(kids[[i]], kids_fitted[[i]])),\n      surrogates = onode$surrogates,\n      info = FUN(onode, fitted))\n  }\n  obj$node <- new_node(node_party(obj), fit)\n\n  class(obj) <- c(\"simpleparty\", \"party\")\n  return(obj)\n}\n\nis.simpleparty <- function(party) {\n\n    chkinfo <- function(node)\n        all(c(\"prediction\", \"n\", \"error\", \"distribution\") %in% names(info_node(node)))\n\n    all(nodeapply(party, ids = nodeids(party), \n                  FUN = chkinfo, by_node = TRUE))\n}\n\n",
    "created" : 1490387443987.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "611737026",
    "id" : "5072406C",
    "lastKnownWriteTime" : 1443524668,
    "last_content_update" : 1443524668,
    "path" : "C:/Users/RJacobucci/Desktop/partykit_1.1-1 (1)/partykit/R/simpleparty.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 14,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}