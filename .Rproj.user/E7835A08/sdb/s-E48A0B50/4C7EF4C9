{
    "collab_server" : "",
    "contents" : "#' Main function for creating different types of decision trees\n#'\n#' @param formula a formula, with a response to left of ~.\n#' @param data Data frame to run models on\n#' @param methods Which tree methods to use. Defaults:\n#'        lm, rpart, ctree, evtree. Also can use \"rf\" for random forests.\n#'        Also a FDR pruning method for ctree termed \"ctreePrune\".\n#'        Finally bumping is implemented as methods=\"bump\".\n#' @param samp.method Sampling method. Refer to caret package trainControl()\n#'        documentation. Default is repeated cross-validation. Other options\n#'        include \"cv\" and \"boot\".\n#' @param tuneLength Number of tuning parameters to try. Applies to train().\n#'        Can also be specified as a vector, with order corresponding to the\n#'        order specified in the methods argument.\n#' @param bump.rep Number of repetitions for bumping\n#' @param subset Whether to split dataset into training and test sets\n#' @param perc.sub What fraction of data to put into train dataset. 1-frac.sub\n#'        is allocated to test dataset. Defaults to 0.75\n#' @param weights Optional weights for each case.\n#' @param verbose Whether to print what method on\n#'\n#' @importFrom stats cor fitted lm predict terms glm binomial sd complete.cases\n#' @importFrom party nodes where\n#' @import rpart evtree caret partykit\n#' @export\n#'\n#' @examples\n#' # continuous outcome\n#' #library(MASS) # for boston data\n#' #data(Boston)\n#' #out <- dtree(medv ~., data=Boston,methods=c(\"lm\",\"rpart\",\"ctree\"))\n#' #summary(out)\n#'# plot(out$rpart.out)\n#'\n#' # categorical outcome\n#' #library(ISLR)\n#' #data(Default)\n#'\n#' #out <- dtree(default ~ ., data=Default,methods=c(\"lm\",\"rpart\"))\n#' #summary(out)\n\n\ndtree = function(formula,\n                 data,\n                 methods=c(\"lm\",\"rpart\",\"tree\",\"ctree\",\"evtree\"),\n                 samp.method=\"repeatedcv\",\n                 tuneLength=3,\n                 bump.rep=50,\n                 subset=FALSE,\n                 perc.sub=.75,\n                 weights=NULL,\n                 verbose=TRUE){\n#options(warn=-1)\n  if(is.null(weights)==FALSE){\n    stop(\"weights are currently not implemented\")\n  }\n\n  ret <- list()\n  if(length(tuneLength)==1){\n    tune.rpart <- tune.ctree <- tune.evtree <- tune.rf <- tuneLength\n  }else{\n    if(any(methods==\"rpart\")){\n      tune.rpart <- tuneLength[methods==\"rpart\"]\n    }\n    if(any(methods==\"ctree\")){\n      tune.ctree <- tuneLength[methods==\"ctree\"]\n    }\n    if(any(methods==\"evtree\")){\n      tune.evtree <- tuneLength[methods==\"evtree\"]\n    }\n    if(any(methods==\"rf\")){\n      tune.rf <- tuneLength[methods==\"rf\"]\n    }\n  }\n\n  if(subset==TRUE){\n    ids <- sample(nrow(data),nrow(data)*perc.sub)\n    data.train <- data[ids,]\n    data.test <- data[-ids,]\n  }else{\n    data.train <- data\n    data.test <- data\n  }\n\n\n  getResponseFormula <- function (object)\n  {\n    form <- formula(object)\n    if (!(inherits(form, \"formula\") && (length(form) == 3))) {\n      stop(\"'form' must be a two-sided formula\")\n    }\n    eval(parse(text = paste(\"~\", deparse(form[[2]]))))\n  }\n\n  response <- attr(terms(getResponseFormula(formula)),\"term.labels\")\n  # ------------------------------------------------------------------\n\n\n  class.response <- class(data.train[,response])\n\n\n  if(class.response == \"numeric\" | class.response == \"integer\"){\n    return.matrix <- matrix(NA,length(methods),7)\n    rownames(return.matrix) <- methods\n    colnames(return.matrix) <- c(\"nodes\",\"nvar\",\"nsplits\",\"rmse.samp\",\n                                 \"rsq.samp\",\"rmse.test\",\"rsq.test\")\n    Metric=\"RMSE\"\n  }else{\n    return.matrix <- matrix(NA,length(methods),7)\n    rownames(return.matrix) <- methods\n    colnames(return.matrix) <- c(\"nodes\",\"nvar\",\"nsplits\",\"auc.samp\",\n                                 \"accuracy.samp\",\"auc.test\",\"accuracy.test\")\n\n    Metric=\"ROC\"\n\n  }\n\n  firstSplit <- matrix(NA,length(methods),2)\n  rownames(firstSplit) <- methods\n  colnames(firstSplit) <- c(\"var\",\"val\")\n  # -----------------------------------------------------------------\n\n  # Linear (Logistic) Regression\n\n  # -----------------------------------------------------------------\n\n  if(any(methods==\"lm\")){\n    if(verbose==TRUE) cat(\"Currently running linear regression\\n\")\n    ret0 <- lm_ret(formula, data.train,data.test,samp.method,tuneLength=1,subset, class.response,response,Metric)\n    return.matrix[\"lm\",] <- ret0$vec\n    ret$lm.out <- ret0$rpart.ret\n    ret$lm.train <- ret0$lm.train\n\n\n\n  }\n\n\n\n  # ------------------------------------------------------------------\n\n  # Rpart\n\n  # ----------------------------------------------------------------\n\n\n  if(any(methods==\"rpart\")){\n    if(verbose==TRUE) cat(\"Currently running\",tune.rpart, \"rpart models\\n\")\n  ret1 <- suppressWarnings(rpart_ret(formula, data.train,data.test,samp.method,tuneLength=tune.rpart,subset, class.response,response,Metric))\n  return.matrix[\"rpart\",] <- ret1$vec\n  ret$rpart.out <- ret1$rpart.ret\n  ret$rpart.train <- ret1$rpart.train\n  ret$rpart.splits <- ret1$return.splits\n  firstSplit[\"rpart\",] <- as.matrix(ret1$firstSplit)\n\n\n  }\n\n  # ----------------------------------------------------\n\n  # Ctree\n\n  # ----------------------------------------------------\n  if(any(methods == \"ctree\")){\n    if(verbose==TRUE) cat(\"Currently running\",tune.ctree, \"ctree models\\n\")\n    ret3 <- ctree_ret(formula, data.train,data.test,samp.method,tuneLength=tune.ctree,subset, class.response,response,Metric)\n    return.matrix[\"ctree\",] <- ret3$vec\n    ret$ctree.out <- ret3$ctree.ret\n    ret$ctree.train <- ret3$ctree.train\n    ret$ctree.splits <- ret3$return.splits\n    firstSplit[\"ctree\",] <- as.matrix(ret3$firstSplit)\n  }\n\n\n  #----------------------------------------------------\n\n  # Evtree\n\n  # ---------------------------------------------------\n\n  if(any(methods == \"evtree\")){\n    if(verbose==TRUE) cat(\"Currently running\",tune.evtree, \"evtree models\\n\")\n    ret4 <- evtree_ret(formula, data.train,data.test,samp.method,tuneLength=tune.evtree,subset, class.response,response,Metric)\n    return.matrix[\"evtree\",] <- ret4$vec\n    ret$evtree.out <- ret4$evtree.ret\n    ret$evtree.train <- ret4$evtree.train\n    ret$evtree.splits <- ret4$return.splits\n    firstSplit[\"evtree\",] <- as.matrix(ret4$firstSplit)\n  }\n\n  #----------------------------------------------------\n\n  # Random Forests\n\n  # ---------------------------------------------------\n\n  if(any(methods == \"rf\")){\n    if(verbose==TRUE) cat(\"Currently running\",tune.rf, \"random forest models\\n\")\n    ret5 <- rf_ret(formula, data.train,data.test,samp.method,tuneLength=tune.rf,subset, class.response,response,Metric)\n    return.matrix[\"rf\",] <- ret5$vec\n    ret$rf.out <- ret5$rf.ret\n    ret$rf.train <- ret5$rf.train\n  }\n\n\n  # ----------------------------------------------------\n\n  # Bumping\n\n  # ----------------------------------------------------\n\n\n  if(any(methods==\"bump\")){\n    if(verbose==TRUE) cat(\"Currently running bumping with\",bump.rep,\"repetitions\\n\")\n    ret6 <- suppressWarnings(bump_ret(formula, data.train,data.test,samp.method,tuneLength=tune.rpart,subset, class.response,response,Metric,bump.rep))\n    return.matrix[\"bump\",] <- ret6$vec\n    ret$bump.matrix <- ret6$bump.matrix\n    ret$bump.list <- ret6$bump.list\n    ret$bump.BestMode <- ret6$BestMod\n    ret$bump.splits <- ret6$return.splits\n    firstSplit[\"bump\",] <- as.matrix(ret6$firstSplit)\n\n\n   # if(ret$BestMod$frame$var == \"<leaf>\"){\n   #   ret$bump.matrix[1,\"nvar\"] <- 0\n   #   ret$bump.matrix[1,\"nodes\"] <- 1\n   #   ret$bump.matrix[1,\"nsplits\"] <- 0\n   # }\n  }\n\n\n  # ----------------------------------------------------\n\n  # CtreePrune\n\n  # ----------------------------------------------------\n  if(any(methods == \"ctreePrune\")){\n    if(verbose==TRUE) cat(\"Currently running ctreePrune\")\n   # formula2 <- terms(formula,data=data.train)\n    #print(formula2)\n   # print(formula)\n    #print(formula2)\n    #ret77 <- do.call(partykit::ctree,list(formula=medv~., data=Boston))\n    ret7 <- ctreePrune_ret(formula,data.train,data.test,class.response,subset,response)\n    return.matrix[\"ctreePrune\",] <- ret7$vec\n    ret$ctreePrune.out <- ret7$ctreePrune.ret\n    ret$ctreePrune.splits <- ret7$return.splits\n    firstSplit[\"ctreePrune\",] <- as.matrix(ret7$firstSplit)\n\n  }\n\n  ret$firstSplit <- firstSplit\n  ret$response.type <- class.response\n  ret$return.matrix <- return.matrix\n  ret$call <- match.call()\n  ret$subset <- subset\n  class(ret) <- \"dtree\"\n  return(ret)\n\n}\n",
    "created" : 1490813536875.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "61819104",
    "id" : "4C7EF4C9",
    "lastKnownWriteTime" : 1490738082,
    "last_content_update" : 1490738082,
    "path" : "~/GitHub/dtree/R/dtree.R",
    "project_path" : "R/dtree.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 11,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}