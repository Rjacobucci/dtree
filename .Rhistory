library(MASS) # for boston data
data(Boston)
rpart.Boston <- rpart::rpart(medv ~., data=Boston,weights=NULL)
plot(rpart.Boston);text(rpart.Boston)
ctree.Boston <- party::ctree(medv ~., data=Boston)
out <- dtree(medv ~., data=Boston)
out
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
out
for(i in 1:niter){
dat <- sim_regDat(500,100,30,rep(.4,30))
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
ret.mat[i,] <- out$return.matrix[,"nodes"]
}
ret.mat
dat
dat <- sim_regDat(500,10,0)
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
out
for(i in 1:niter){
#dat <- sim_regDat(500,10,0)
dat <- sim_regDat(500,100,30,rep(.8,30))
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
ret.mat[i,] <- out$return.matrix[,"nodes"]
}
ret.mat
str(dat)
dat <- sim_regDat(500,100,30,rep(.8,30))
cor(dat)
dat <- sim_regDat(500,10,3,rep(.3,3))
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
out
out <- dtree(y ~ ., data.matrix(dat),methods=c("rpart","ctree","evtree"))
out <- dtree(y ~ ., as.matrix(dat),methods=c("rpart","ctree","evtree"))
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
out
evtree(y ~ ., dat)
var(dat$y)
sim_regDat <- function(N,P,nonzero.num=NULL,beta.nonzero=NULL){
x=data.frame(matrix(rnorm(P*N),ncol=P))
if(is.null(nonzero.num)==TRUE){
beta <- rep(0,P)
}else{
beta <- c(beta.nonzero,rep(0,P-nonzero.num))
}
y <- as.matrix(x)%*%beta + rnorm(nrow(x),0,3)
return(data.frame(y,x))
}
dat <- sim_regDat(500,10,3,rep(.3,3))
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
out
var(dat$y)
evtree(y ~ ., dat)
sim_regDat <- function(N,P,nonzero.num=NULL,beta.nonzero=NULL){
x=data.frame(matrix(rnorm(P*N),ncol=P))
if(is.null(nonzero.num)==TRUE){
beta <- rep(0,P)
}else{
beta <- c(beta.nonzero,rep(0,P-nonzero.num))
}
y <- as.matrix(x)%*%beta + rnorm(nrow(x),0,1)
return(data.frame(y,x))
}
sim_regDat <- function(N,P,nonzero.num=NULL,beta.nonzero=NULL){
x=data.frame(matrix(rnorm(P*N),ncol=P))
if(is.null(nonzero.num)==TRUE){
beta <- rep(0,P)
}else{
beta <- c(beta.nonzero,rep(0,P-nonzero.num))
}
y <- as.matrix(x)%*%beta + rnorm(nrow(x),0,1)
return(data.frame(y,x))
}
dat <- sim_regDat(500,10,3,c(1,1,1))
evtree(y ~ ., dat)
var(dat$y)
sim_regDat <- function(N,P,nonzero.num=NULL,beta.nonzero=NULL){
x=data.frame(matrix(rnorm(P*N),ncol=P))
if(is.null(nonzero.num)==TRUE){
beta <- rep(0,P)
}else{
beta <- c(beta.nonzero,rep(0,P-nonzero.num))
}
y <- as.matrix(x)%*%beta + rnorm(nrow(x),0,1)
return(data.frame(y,x))
}
dat <- sim_regDat(500,10,3,c(1,1,1))
evtree(y ~ ., dat)
install.packages("evtree", repos="http://R-Forge.R-project.org")
library(dtree)
niter <- 100
ret.mat <- matrix(NA,niter,3)
for(i in 1:niter){
#dat <- sim_regDat(500,10,0)
#dat <- sim_regDat(500,100,30,rep(.8,30))
dat <- sim_regDat(500,10,3,rep(.3,3))
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
ret.mat[i,] <- out$return.matrix[,"nodes"]
}
colMeans(ret.mat)
ret.mat
niter <- 100
ret.mat <- matrix(NA,niter,3)
for(i in 1:niter){
#dat <- sim_regDat(500,10,0)
#dat <- sim_regDat(500,100,30,rep(.8,30))
dat <- sim_regDat(500,10,0)
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
ret.mat[i,] <- out$return.matrix[,"nodes"]
}
colMeans(ret.mat)
?glm
lm.out <- lm(formula,data.train)
lm.out
p_s <- summary(out)$coefficients[,"Pr(>|t|)"] < 0.05
p_s <- summary(out)$coefficients[,"Pr(>|t|)"] < 0.05
p_s
p_s <- summary(lm.out)$coefficients[,"Pr(>|t|)"] < 0.05
p_s
library(dtree)
library(MASS) # for boston data
data(Boston)
out <- dtree(medv ~., data=Boston)
library(dtree)
out <- dtree(medv ~., data=Boston)
out
dim(Boston)
install.packages("randomForest")
rf.out <- train(formula,data.train,method="rf",trControl=trainControl(method="cv"))
library(caret)
rf.out <- train(formula,data.train,method="rf",trControl=trainControl(method="cv"))
data.train=dat
data.train=Boston
rf.out <- train(formula,data.train,method="rf",trControl=trainControl(method="cv"))
formula
formula=medv ~ .
rf.out <- train(formula,data.train,method="rf",trControl=trainControl(method="cv"))
rf.out
importance(rf.out)
rf.out <- train(formula,data.train,method="rf",
trControl=trainControl(method="cv"),importance=TRUE)
importance(rf.out)
varImp(rf.out)
?train
library(dtree)
out <- dtree(medv ~., data=Boston,methods=c("lm","evtree","rf"))
summary(out)
rf.out
summary(rf.out)
str(rf.out)
rf.out$finalModel$resample$RMSE
rf.out$finalModel$resample
rf.out$resample
rf.out$resample$RMSE
mean(rf.out$resample$RMSE)
summary(out)
mean(rf.out$resample$RMSE)/nrow(data.train)
rf.out$results$RMSE
min(rf.out$results$RMSE)
?trainControl
min(rf.out$results$RMSE)/(.75*nrow(data.train))
library(dtree)
out <- dtree(medv ~., data=Boston,methods=c("lm","rpart","rf"))
summary(out)
library(dtree)
library(dtree)
library(dtree)
library(dtree)
library(dtree)
library(dtree)
library(dtree)
?nodes
library(dtree)
library(dtree)
library(dtree)
library(dtree)
library(dtree)
library(dtree)
library(dtree)
library(dtree)
library(dtree)
library(dtree)
library(dtree)
library(dtree)
library(dtree)
library(dtree)
library(dtree)
library(dtree)
library(dtree)
install.packages("ISLR")
library(ISLR)
install.packages("ISLR")
library(ISLR)
data(Default)
str(Default)
lr.out <- glm(default~.,family="binomial",data=Default)
summary(lr.out)
?evtree
1 - mean(predict(lr.out) == Default$default)
Default$default
predict(lr.out)
1 - mean(predict(lr.out,type="response") == Default$default)
predict(lr.out,type="response")
?predict.glm
predict(lr.out,type="terms")
predict(lr.out)
round(predict(lr.out))
round(predict(lr.out,type="link"))
round(predict(lr.out,type="response"))
round(predict(lr.out,type="response")) == Default$default
Default$default
1 - mean(round(predict(lr.out,type="response")) == as.numeric(Default$default))
as.numeric(Default$default)
round(predict(lr.out,type="response"))
round(predict(lr.out,type="response"))+1
1 - mean(round(predict(lr.out,type="response"))+1 == as.numeric(Default$default))
round(predict(lr.out,type="response"))+1
mean(round(predict(lr.out,type="response"))+1 == as.numeric(Default$default))
summary(lr.out)
library(dtree)
out <- dtree(default ~ ., data=Default)
library(dtree)
out <- dtree(default ~ ., data=Default)
library(dtree)
out <- dtree(default ~ ., data=Default)
Default$default
str(Default)
library(dtree)
out <- dtree(default ~ ., data=Default)
out <- dtree(default ~ ., data=Default)
library(dtree)
library(dtree)
out <- dtree(default ~ ., data=Default)
library(dtree)
?dtree
out <- dtree(default ~ ., data=Default,methods=c("lm","rpart"))
out <- dtree(default ~ ., data=Default,methods=c("lm"))
summary(out)
library(dtree)
out2 <- rpart(default ~ ., data=Default)
summary(out)
out2
rpart.out=out2
cp <- rpart.out$cptable
min.error <- which(min(cp[,"xerror"]) == cp[,"xerror"])[1]
return.matrix[1,"nsplits"] <- cp[min.error,"nsplit"]
cp[min.error,"xerror"]
predict(out2)
library(dtree)
out <- dtree(default ~ ., data=Default,methods=c("lm","rpart"))
summary(out)
evtree.out <- evtree::evtree(default ~ ., data=Default)
evtree.out
predict(evtree.out)
as.numeric(predict(evtree.out))
library(dtree)
out <- dtree(default ~ ., data=Default,methods=c("lm","rpart","evtree"))
summary(out)
plot(out$evtree.out)
library(dtree)
library(dtree)
library(dtree)
library(dtree)
library(MASS) # for boston data
data(Boston)
out <- dtree(medv ~., data=Boston,methods=c("lm","rpart","ctree"))
str(Boston)
class(Boston[,"medv"])
traceback()
library(dtree)
out <- dtree(medv ~., data=Boston,methods=c("lm","rpart","ctree"))
out <- dtree(medv ~., data=Boston,methods=c("lm","rpart","ctree"))
summary(out)
out <- dtree(default ~ ., data=Default,methods=c("lm","rpart"))
summary(out)
lm.out <- glm(formula,family=binomial,data.train)
lr.out <- glm(default~.,family="binomial",data=Default)
str(lr.out)
summary(lr.out)
str(summary(lr.out))
summary(lr.out)$coefficients
summary(lr.out)$coefficients[,"Pr(>|z|)"]
summary(lr.out)$coefficients[,"Pr(>|z|)"][-1]
sum(summary(lr.out)$coefficients[,"Pr(>|z|)"][-1] < .05)
library(dtree)
lr.out <- glm(default~.,family="binomial",data=Default)
out <- dtree(default ~ ., data=Default,methods=c("lm","rpart"))
summary(out)
out <- dtree(default ~ ., data=Default,methods=c("lm","rpart","ctree"))
library(dtree)
out <- dtree(default ~ ., data=Default,methods=c("lm","rpart","ctree"))
summary(out)
predict(out$ctree.out)
out <- dtree(default ~ ., data=Default,methods=c("lm","rpart","ctree","evtree"))
summary(out)
plot(out$ctree.out)
plot(out$evtree.out)
library(dtree)
library(dtree)
out <- dtree(default ~ ., data=Default,methods=c("lm","rpart","tree"))
summary(out)
data=Default
formula= default ~ .
methods="tree"
ret <- list()
perc.sub=.7
ids <- sample(nrow(data),nrow(data)*perc.sub)
data.train <- data[ids,]
data.test <- data[-ids,]
getResponseFormula <- function (object)
{
form <- formula(object)
if (!(inherits(form, "formula") && (length(form) == 3))) {
stop("'form' must be a two-sided formula")
}
eval(parse(text = paste("~", deparse(form[[2]]))))
}
response <- attr(terms(getResponseFormula(formula)),"term.labels")
class.response <- class(data.train[,response])
if(class.response == "numeric" | class.response == "integer"){
return.matrix <- matrix(NA,length(methods),8)
rownames(return.matrix) <- methods
colnames(return.matrix) <- c("nodes","nvar","nsplits","misfit.cv",
"misfit.train","rsq.train","misfit.test","rsq.test")
}else{
return.matrix <- matrix(NA,length(methods),6)
rownames(return.matrix) <- methods
colnames(return.matrix) <- c("nodes","nvar","nsplits","accuracy.cv",
"accuracy.train","accuracy.test")
}
ret <- list()
if(class.response == "numeric" | class.response == "integer"){
return.matrix <- matrix(NA,1,8)
colnames(return.matrix) <- c("nodes","nvar","nsplits","misfit.cv",
"misfit.train","rsq.train","misfit.test","rsq.test")
}else{
return.matrix <- matrix(NA,1,6)
colnames(return.matrix) <- c("nodes","nvar","nsplits","accuracy.cv",
"accuracy.train","accuracy.test")
}
tree1 <- tree::tree(formula,data.train)
cv1 <- tree::cv.tree(tree1)
min.loc <- which(min(cv1$dev) == cv1$dev)
return.matrix[1,"nodes"] <- cv1$size[min.loc]
pruned.tree <- tree::prune.tree(tree1,cv1$k[min.loc])
return.matrix[1,"fit.cv"] <- cv1$dev[min.loc]/nrow(data.train)
if(class.response == "numeric" | class.response == "integer"){
#return.matrix[1,"misfit.cv"] <- cp[min.error,"xerror"]
return.matrix[1,"misfit.train"] <- mean((data.train[,response] - predict(tree1))^2)/nrow(data.train)
return.matrix[1,"misfit.test"] <- mean((data.test[,response] -
predict(tree1,data.test))^2)/nrow(data.test)
return.matrix[1,"rsq.train"] <- (cor(data.train[,response],predict(rpart.out)))**2
return.matrix[1,"rsq.test"] <- (cor(data.test[,response],predict(rpart.out,data.test)))**2
}else{
return.matrix[1,"accuracy.cv"] <- cp[min.error,"xerror"]
return.matrix[1,"accuracy.train"] <- mean(round(predict(tree1)[,2])+1 == as.numeric(data.train[,response]))
return.matrix[1,"accuracy.test"] <- mean(round(predict(tree1 ,data.test)[,2])+1 == as.numeric(data.test[,response]))
}
library(dtree)
out <- dtree(default ~ ., data=Default,methods=c("lm","rpart","tree"))
summary(out)
return.matrix
cp[min.error,"xerror"]
mean(round(predict(tree1)[,2])+1 == as.numeric(data.train[,response]))
predict(tree1)
str(tree1)
return.matrix[1,"accuracy.train"] <- mean(round(predict(tree1)[,2])+1 == as.numeric(data.train[,response]))
mean(round(predict(tree1)[,2])+1 == as.numeric(data.train[,response]))
mean(round(predict(tree1 ,data.test)[,2])+1 == as.numeric(data.test[,response]))
pruned.tree
cv1$k
which(min(cv1$dev) == cv1$dev)
return.matrix[1,"accuracy.train"] <- mean(round(predict(pruned.tree)[,2])+1 == as.numeric(data.train[,response]))
pruned.tree <- tree::prune.tree(tree1,cv1$k[min.loc])
pruned.tree
predict(pruned.tree)
?prune.tree
plot(pruned.tree)
plot(cv1)
predict(cv1)
?prune.tree
data(fgl, package="MASS")
fgl.tr <- tree(type ~ ., fgl)
plot(print(fgl.tr))
fgl.cv <- cv.tree(fgl.tr,, prune.tree)
for(i in 2:5)  fgl.cv$dev <- fgl.cv$dev +
cv.tree(fgl.tr,, prune.tree)$dev
fgl.cv$dev <- fgl.cv$dev/5
plot(fgl.cv)
library(tree)
data(fgl, package="MASS")
fgl.tr <- tree(type ~ ., fgl)
plot(print(fgl.tr))
fgl.cv <- cv.tree(fgl.tr,, prune.tree)
for(i in 2:5)  fgl.cv$dev <- fgl.cv$dev +
cv.tree(fgl.tr,, prune.tree)$dev
fgl.cv$dev <- fgl.cv$dev/5
plot(fgl.cv)
?plot.tree
plot(tree1)
?tree
?prune.tree
cv1$k[min.loc]
pruned.tree <- tree::prune.tree(tree1,k=cv1$k[min.loc])
plot(pruned.tree)
pruned.tree <- tree::prune.tree(tree1,best=4)#k=cv1$k[min.loc])
plot(pruned.tree)
cv1
cv1$size[min.loc]
pruned.tree <- tree::prune.tree(tree1,best=cv1$size[min.loc])
predict(pruned.tree)
pruned.tree
str(pruned.tree)
pruned.tree$frame
pruned.tree$frame[,"var"]
unique(pruned.tree$frame[,"var"])
unique(pruned.tree$frame[,"var"])[-"<leaf>"]
unique(pruned.tree$frame[,"var"])[!"<leaf>"]
unique(pruned.tree$frame[,"var"]) == "<leaf>"
uniq <- unique(pruned.tree$frame[,"var"])
uniq[uniq != "<leaf>"]
length(uniq[uniq != "<leaf>"])
nrow(pruned.tree$frame[,"var"]) - cv1$size[min.loc]
nrow(pruned.tree$frame[,"var"])
length(pruned.tree$frame[,"var"]) - cv1$size[min.loc]
library(dtree)
out <- dtree(default ~ ., data=Default,methods=c("lm","rpart","tree"))
summary(out)
ret <- list()
if(class.response == "numeric" | class.response == "integer"){
return.matrix <- matrix(NA,1,8)
colnames(return.matrix) <- c("nodes","nvar","nsplits","misfit.cv",
"misfit.train","rsq.train","misfit.test","rsq.test")
}else{
return.matrix <- matrix(NA,1,6)
colnames(return.matrix) <- c("nodes","nvar","nsplits","accuracy.cv",
"accuracy.train","accuracy.test")
}
tree1 <- tree::tree(formula,data.train)
cv1 <- tree::cv.tree(tree1)
min.loc <- which(min(cv1$dev) == cv1$dev)
return.matrix[1,"nodes"] <- cv1$size[min.loc]
pruned.tree <- tree::prune.tree(tree1,best=cv1$size[min.loc])
return.matrix[1,"nodes"] <- cv1$size[min.loc]
uniq <- unique(pruned.tree$frame[,"var"])
return.matrix[1,"nvar"] <- length(uniq[uniq != "<leaf>"])
return.matrix[1,"nsplits"] <- length(pruned.tree$frame[,"var"]) - cv1$size[min.loc]
#vars <- rpart.ret$frame[,"var"]
#vars2 <- vars[vars != "<leaf>"]
#return.matrix[1,"nvar"] <- length(unique(vars2))
if(class.response == "numeric" | class.response == "integer"){
#return.matrix[1,"misfit.cv"] <- cp[min.error,"xerror"]
return.matrix[1,"misfit.train"] <- mean((data.train[,response] - predict(pruned.tree))^2)/nrow(data.train)
return.matrix[1,"misfit.test"] <- mean((data.test[,response] -
predict(pruned.tree,data.test))^2)/nrow(data.test)
return.matrix[1,"rsq.train"] <- (cor(data.train[,response],predict(pruned.tree)))**2
return.matrix[1,"rsq.test"] <- (cor(data.test[,response],predict(pruned.tree,data.test)))**2
}else{
#return.matrix[1,"accuracy.cv"] <- cp[min.error,"xerror"]
return.matrix[1,"accuracy.train"] <- mean(round(predict(pruned.tree)[,2])+1 == as.numeric(data.train[,response]))
return.matrix[1,"accuracy.test"] <- mean(round(predict(pruned.tree ,data.test)[,2])+1 == as.numeric(data.test[,response]))
}
return.matrix
out <- dtree(default ~ ., data=Default,methods=c("lm","rpart","tree"))
library(dtree)
out <- dtree(default ~ ., data=Default,methods=c("lm","rpart","tree"))
summary(out)
plot(out$tree.out)
out <- dtree(default ~ ., data=Default,methods=c("lm","rpart","tree","rf"))
install.packages("e1071")
library(dtree)
out <- dtree(default ~ ., data=Default,methods=c("lm","rpart","tree","rf"))
library(dtree)
out <- dtree(default ~ ., data=Default,methods=c("lm","rpart","tree","rf"))
if(class.response == "numeric" | class.response == "integer"){
return.matrix <- matrix(NA,1,8)
colnames(return.matrix) <- c("nodes","nvar","nsplits","misfit.cv",
"misfit.train","rsq.train","misfit.test","rsq.test")
}else{
return.matrix <- matrix(NA,1,6)
colnames(return.matrix) <- c("nodes","nvar","nsplits","accuracy.cv",
"accuracy.train","accuracy.test")
}
if(class.response == "numeric" | class.response == "integer"){
rf.out <- train(formula,data.train,method="rf",
trControl=trainControl(method="cv"),importance=TRUE)
}else{
rf.out <- train(formula,data.train,method="rf",metric="Accuracy",
trControl=trainControl(method="cv"),importance=TRUE)
}
predict(rf.out)
mean(round(predict(rf.out))+1 == as.numeric(data.train[,response]))
mean(predict(rf.out) == data.train[,response])
mean(predict(rf.out,data.test) == data.test[,response])
rf.out
str(rf.out)
max(rf.out$results$Accuracy)
library(dtree)
out <- dtree(default ~ ., data=Default,methods=c("lm","rpart","tree","rf"))
summary(out)
out <- dtree(default ~ ., data=Default,methods=c("lm","rpart","tree","rf","evtree","ctree"))
summary(out)
cv1
?cv.tree
cv1 <- tree::cv.tree(tree1,prune.tree)
cv.tree(tree1,prune.tree)
cv1 <- tree::cv.tree(tree1,,prune.tree)
cv1
?tree
train(formula,data.train,method="tree",metric="Accuracy",
trControl=trainControl(method="cv"),importance=TRUE)
library(dtree)
