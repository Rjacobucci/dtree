for(i in 1:len){
if(is.null(ret.obj[[i]]$split$varid)==FALSE){
vars[i] <- ret.obj[[i]]$split$varid
}else{
vars[i] <- NA
}
}
vars2 <- vars[is.na(vars)==FALSE]
vars3 <- length(unique(vars2))
#attributes(evtree.out)
return.matrix[1,"nvar"] <- vars3
return.matrix[1,"nodes"] <- length(unique(fitted(evtree.out)[,1]))
if(class.response == "numeric" | class.response == "integer"){
return.matrix[1,"fit.test"] <- mean((data.test[,response] -
predict(evtree.out,data.test))^2)/nrow(data.test)
}else{
return.matrix[1,"fit.test"] <- NA
}
return.matrix
library(dtree)
out <- dtree(medv ~., data=Boston)
summary(out)
library(MASS) # for boston data
data(Boston)
formula= medv ~ .,
formula= medv ~ .
data=Boston
methods=c("rpart","tree","ctree","evtree")
perc.sub=.5
ret <- list()
return.matrix <- matrix(NA,length(methods),6)
rownames(return.matrix) <- methods
colnames(return.matrix) <- c("nodes","nvar","nsplits","fit.cv","fit.train","fit.test")
ids <- sample(nrow(data),nrow(data)*perc.sub)
data.train <- data[ids,]
data.test <- data[-ids,]
if(any(methods == "evtree")){
ret4 <- evtree_ret(formula, data.train,data.test, class.response,response)
return.matrix["evtree",] <- ret4$vec
ret$evtree.out <- ret4$evtree.ret
}
ret <- list()
return.matrix <- matrix(NA,1,6)
colnames(return.matrix) <- c("nodes","nvar","nsplits","fit.cv","fit.train","fit.test")
evtree.out <- evtree(formula,data.train)
#min.error <- which(min(cp[,"xerror"]) == cp[,"xerror"])[1]
return.matrix[1,"nsplits"] <- max(fitted(evtree.out)[,1]) - length(unique(fitted(evtree.out)[,1]))
#return.matrix[1,"fit.cv"] <- cp[min.error,"xerror"]
return.matrix[1,"fit.train"] <- mean((data.train[,response] - predict(evtree.out))^2)/nrow(data.train)
#depth(evtree.out$node)
ret.obj <- as.list(evtree.out$node)
len <- length(ret.obj)
vars <- rep(NA,len)
for(i in 1:len){
if(is.null(ret.obj[[i]]$split$varid)==FALSE){
vars[i] <- ret.obj[[i]]$split$varid
}else{
vars[i] <- NA
}
}
vars2 <- vars[is.na(vars)==FALSE]
vars3 <- length(unique(vars2))
#attributes(evtree.out)
return.matrix[1,"nvar"] <- vars3
return.matrix[1,"nodes"] <- length(unique(fitted(evtree.out)[,1]))
if(class.response == "numeric" | class.response == "integer"){
return.matrix[1,"fit.test"] <- mean((data.test[,response] -
predict(evtree.out,data.test))^2)/nrow(data.test)
}else{
return.matrix[1,"fit.test"] <- NA
}
return.matrix
return.matrix[1,"nsplits"] <- max(fitted(evtree.out)[,1]) - length(unique(fitted(evtree.out)[,1]))
#return.matrix[1,"fit.cv"] <- cp[min.error,"xerror"]
return.matrix[1,"fit.train"] <- mean((data.train[,response] - predict(evtree.out))^2)/nrow(data.train)
predict(evtree.out)
data.train[,response]
getResponseFormula <- function (object)
{
form <- formula(object)
if (!(inherits(form, "formula") && (length(form) == 3))) {
stop("'form' must be a two-sided formula")
}
eval(parse(text = paste("~", deparse(form[[2]]))))
}
response <- attr(terms(getResponseFormula(formula)),"term.labels")
# ------------------------------------------------------------------
class.response <- class(data.train[,response])
#min.error <- which(min(cp[,"xerror"]) == cp[,"xerror"])[1]
return.matrix[1,"nsplits"] <- max(fitted(evtree.out)[,1]) - length(unique(fitted(evtree.out)[,1]))
#return.matrix[1,"fit.cv"] <- cp[min.error,"xerror"]
return.matrix[1,"fit.train"] <- mean((data.train[,response] - predict(evtree.out))^2)/nrow(data.train)
#depth(evtree.out$node)
ret.obj <- as.list(evtree.out$node)
len <- length(ret.obj)
vars <- rep(NA,len)
for(i in 1:len){
if(is.null(ret.obj[[i]]$split$varid)==FALSE){
vars[i] <- ret.obj[[i]]$split$varid
}else{
vars[i] <- NA
}
}
vars2 <- vars[is.na(vars)==FALSE]
vars3 <- length(unique(vars2))
#attributes(evtree.out)
return.matrix[1,"nvar"] <- vars3
return.matrix[1,"nodes"] <- length(unique(fitted(evtree.out)[,1]))
if(class.response == "numeric" | class.response == "integer"){
return.matrix[1,"fit.test"] <- mean((data.test[,response] -
predict(evtree.out,data.test))^2)/nrow(data.test)
}else{
return.matrix[1,"fit.test"] <- NA
}
return.matrix
evtree_ret <- function(formula, data.train, data.test, prune, class.response, response){
ret <- list()
return.matrix <- matrix(NA,1,6)
colnames(return.matrix) <- c("nodes","nvar","nsplits","fit.cv","fit.train","fit.test")
evtree.out <- evtree(formula,data.train)
#min.error <- which(min(cp[,"xerror"]) == cp[,"xerror"])[1]
return.matrix[1,"nsplits"] <- max(fitted(evtree.out)[,1]) - length(unique(fitted(evtree.out)[,1]))
#return.matrix[1,"fit.cv"] <- cp[min.error,"xerror"]
return.matrix[1,"fit.train"] <- mean((data.train[,response] - predict(evtree.out))^2)/nrow(data.train)
#depth(evtree.out$node)
ret.obj <- as.list(evtree.out$node)
len <- length(ret.obj)
vars <- rep(NA,len)
for(i in 1:len){
if(is.null(ret.obj[[i]]$split$varid)==FALSE){
vars[i] <- ret.obj[[i]]$split$varid
}else{
vars[i] <- NA
}
}
vars2 <- vars[is.na(vars)==FALSE]
vars3 <- length(unique(vars2))
#attributes(evtree.out)
return.matrix[1,"nvar"] <- vars3
return.matrix[1,"nodes"] <- length(unique(fitted(evtree.out)[,1]))
if(class.response == "numeric" | class.response == "integer"){
return.matrix[1,"fit.test"] <- mean((data.test[,response] -
predict(evtree.out,data.test))^2)/nrow(data.test)
}else{
return.matrix[1,"fit.test"] <- NA
}
ret$vec <- return.matrix
ret$evtree.ret <- evtree.out
return(ret)
}
ret4 <- evtree_ret(formula, data.train,data.test, class.response,response)
ret4
mean((data.test[,response] -
predict(evtree.out,data.test))^2)/nrow(data.test)
return.matrix
evtree_ret <- function(formula, data.train, data.test,class.response, response){
ret <- list()
return.matrix <- matrix(NA,1,6)
colnames(return.matrix) <- c("nodes","nvar","nsplits","fit.cv","fit.train","fit.test")
evtree.out <- evtree(formula,data.train)
#min.error <- which(min(cp[,"xerror"]) == cp[,"xerror"])[1]
return.matrix[1,"nsplits"] <- max(fitted(evtree.out)[,1]) - length(unique(fitted(evtree.out)[,1]))
#return.matrix[1,"fit.cv"] <- cp[min.error,"xerror"]
return.matrix[1,"fit.train"] <- mean((data.train[,response] - predict(evtree.out))^2)/nrow(data.train)
#depth(evtree.out$node)
ret.obj <- as.list(evtree.out$node)
len <- length(ret.obj)
vars <- rep(NA,len)
for(i in 1:len){
if(is.null(ret.obj[[i]]$split$varid)==FALSE){
vars[i] <- ret.obj[[i]]$split$varid
}else{
vars[i] <- NA
}
}
vars2 <- vars[is.na(vars)==FALSE]
vars3 <- length(unique(vars2))
#attributes(evtree.out)
return.matrix[1,"nvar"] <- vars3
return.matrix[1,"nodes"] <- length(unique(fitted(evtree.out)[,1]))
if(class.response == "numeric" | class.response == "integer"){
return.matrix[1,"fit.test"] <- mean((data.test[,response] -
predict(evtree.out,data.test))^2)/nrow(data.test)
}else{
return.matrix[1,"fit.test"] <- NA
}
ret$vec <- return.matrix
ret$evtree.ret <- evtree.out
return(ret)
}
ret4 <- evtree_ret(formula, data.train,data.test, class.response,response)
ret4
library(dtree)
out <- dtree(medv ~., data=Boston)
summary(out)
library(dtree)
library(dtree)
data
ret <- list()
return.matrix <- matrix(NA,1,6)
colnames(return.matrix) <- c("nodes","nvar","nsplits","misfit.cv","misfit.train","rsq.train","misfit.test","rsq.test")
evtree.out <- evtree(formula,data.train)
return.matrix <- matrix(NA,1,9)
colnames(return.matrix) <- c("nodes","nvar","nsplits","misfit.cv","misfit.train","rsq.train","misfit.test","rsq.test")
length(c("nodes","nvar","nsplits","misfit.cv","misfit.train","rsq.train","misfit.test","rsq.test"))
return.matrix <- matrix(NA,1,8)
colnames(return.matrix) <- c("nodes","nvar","nsplits","misfit.cv","misfit.train","rsq.train","misfit.test","rsq.test")
evtree.out <- evtree(formula,data.train)
return.matrix[1,"misfit.train"] <- mean((data.train[,response] - predict(evtree.out))^2)/nrow(data.train)
return.matrix[1,"misfit.test"] <- mean((data.test[,response] -
predict(evtree.out,data.test))^2)/nrow(data.test)
return.matrix[1,"rsq.train"] <- (cor(data.train[,response],predict(evtree.out)))**2
return.matrix[1,"rsq.test"] <- (cor(data.test[,response],predict(evtree.out,data.test)))**2
return.matrix
library(dtree)
out <- dtree(medv ~., data=Boston)
traceback()
library(dtree)
out <- dtree(medv ~., data=Boston)
library(dtree)
out <- dtree(medv ~., data=Boston)
summary(out)
sim_regDat <- function(N,P,nonzero.num=NULL,beta.nonzero=NULL){
x=data.frame(matrix(rnorm(P*N),ncol=P))
if(is.null(nonzero.num)==TRUE){
beta <- rep(0,P)
}else{
beta <- c(beta.nonzero,rep(0,P-nonzero.num))
}
y <- as.matrix(x)%*%beta + rnorm(nrow(x),0,1)
return(data.frame(y,x))
}
install.packages("party")
sim_regDat <- function(N,P,nonzero.num=NULL,beta.nonzero=NULL){
x=data.frame(matrix(rnorm(P*N),ncol=P))
if(is.null(nonzero.num)==TRUE){
beta <- rep(0,P)
}else{
beta <- c(beta.nonzero,rep(0,P-nonzero.num))
}
y <- as.matrix(x)%*%beta + rnorm(nrow(x),0,1)
return(data.frame(y,x))
}
install.packages("caret")
install.packages("evtree")
install.packages("tree")
library(dtree)
niter <- 1
for(i in 1:niter){
dat <- sim_regDat(500,10,0)
out <- dtree(y ~ ., dat)
}
dat <- sim_regDat(500,10,0)
summary(dat)
out <- dtree(y ~ ., dat)
?dtree
out <- dtree(y ~ ., dat,methods=c("rpart","evtree"))
out <- dtree(y ~ ., dat,methods=c("rpart"))
out
summary(out)
out <- dtree(y ~ ., dat,methods=c("rpart","tree"))
out
out <- dtree(y ~ ., dat,methods=c("rpart","ctree"))
formula = y ~ .
data.train <- dat
data.test <- dat
getResponseFormula <- function (object)
{
form <- formula(object)
if (!(inherits(form, "formula") && (length(form) == 3))) {
stop("'form' must be a two-sided formula")
}
eval(parse(text = paste("~", deparse(form[[2]]))))
}
response <- attr(terms(getResponseFormula(formula)),"term.labels")
class.response <- class(data.train[,response])
ret <- list()
return.matrix <- matrix(NA,1,8)
colnames(return.matrix) <- c("nodes","nvar","nsplits","misfit.cv","misfit.train","rsq.train","misfit.test","rsq.test")
ctree.out <- ctree(formula,data.train)
library(party)
ctree.out <- ctree(formula,data.train)
nodes <- ctree.out@get_where()
return.matrix[1,"nsplits"] <- max(nodes) - length(unique(nodes))
preds <- predict(ctree.out)
node.try <- subset(1:max(nodes), !(1:max(nodes) %in% unique(nodes)))
var.name <- rep(NA,length(node.try))
for(i in 1:length(var.name)){
var.name[i] <- nodes(ctree.out,node.try[i])[[1]]$psplit$variableName
}
return.matrix[1,"nvar"] <- length(unique(var.name))
node.try <- subset(1:max(nodes), !(1:max(nodes) %in% unique(nodes)))
var.name <- rep(NA,length(node.try))
for(i in 1:length(var.name)){
var.name[i] <- nodes(ctree.out,node.try[i])[[1]]$psplit$variableName
}
nodes(ctree.out)
ctree.out
if(class.response == "numeric" | class.response == "integer"){
return.matrix[1,"misfit.train"] <- mean((data.train[,response] - predict(ctree.out))^2)/nrow(data.train)
return.matrix[1,"misfit.test"] <- mean((data.test[,response] -
predict(ctree.out,data.test))^2)/nrow(data.test)
return.matrix[1,"rsq.train"] <- (cor(data.train[,response],predict(ctree.out)))**2
return.matrix[1,"rsq.test"] <- (cor(data.test[,response],predict(ctree.out,data.test)))**2
}else{
return.matrix[1,"misfit.train"] <- NA
return.matrix[1,"misfit.test"] <- NA
}
return.matrix[1,"nvar"] <- length(unique(var.name))
return.matrix[1,"nodes"] <- length(unique(nodes))
return.matrix
length(unique(var.name))
) %
node.try <- subset(1:max(nodes), !(1:max(nodes) %in% unique(nodes)))
node.try
var.name <- rep(NA,length(node.try))
var.name
length(var.name)
library(dtree)
out <- dtree(y ~ ., dat,methods=c("rpart","ctree"))
out <- dtree(y ~ ., dat,methods=c("rpart","ctree"))
library(dtree)
out <- dtree(y ~ ., dat,methods=c("rpart","ctree"))
out
suppressWarnings(mean((data.train[,response] - predict(ctree.out))^2)/nrow(data.train))
suppressWarnings((cor(data.train[,response],predict(ctree.out)))**2)
cor(data.train[,response],predict(ctree.out))
suppressWarnings((cor(data.test[,response],predict(ctree.out,data.test)))**2)
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
ret <- list()
return.matrix <- matrix(NA,1,8)
colnames(return.matrix) <- c("nodes","nvar","nsplits","misfit.cv","misfit.train","rsq.train","misfit.test","rsq.test")
evtree.out <- evtree(formula,data.train)
library(evtree)
evtree.out <- evtree(formula,data.train)
formula
head(data.train)
library(evtree)
evtree.out <- evtree(formula,data.train)
summary(data.train)
?evtree
evtree(formula,dat)
evtree(y ~ ., data=dat)
str(dat)
evtree(y ~ X1 + X2, data=dat)
dat$y
dat <- sim_regDat(500,10,0)
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
dat <- sim_regDat(500,10,0)
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
dat <- sim_regDat(100,10,0)
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
dat <- sim_regDat(100,100,0)
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
str(dat)
dat <- sim_regDat(100,10,0)
str(dat)
?try
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
library(dtree)
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
out
niter <- 100
ret <- list()
for(i in 1:niter){
dat <- sim_regDat(100,10,0)
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
ret[[i]] <- out$return.matrix
}
ret
?lapply
lapply(ret,mean)
out <- dtree(y ~ ., dat,methods=c("rpart","tree","ctree","evtree"))
out
niter <- 100
ret.mat <- matrix(NA,niter,3)
for(i in 1:niter){
dat <- sim_regDat(100,10,0)
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
ret.mat[i,] <- out$return.matrix[,"nodes"]
}
ret.mat
colMeans(ret.mat)
for(i in 1:niter){
dat <- sim_regDat(100,100,0)
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
ret.mat[i,] <- out$return.matrix[,"nodes"]
}
colMeans(ret.mat)
for(i in 1:niter){
dat <- sim_regDat(1000,10,0)
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
ret.mat[i,] <- out$return.matrix[,"nodes"]
}
colMeans(ret.mat)
for(i in 1:niter){
dat <- sim_regDat(50,10,0)
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
ret.mat[i,] <- out$return.matrix[,"nodes"]
}
colMeans(ret.mat)
for(i in 1:niter){
dat <- sim_regDat(50,10,3,c(.1,.1,.1))
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
ret.mat[i,] <- out$return.matrix[,"nodes"]
}
colMeans(ret.mat)
for(i in 1:niter){
dat <- sim_regDat(500,10,3,c(.1,.1,.1))
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
ret.mat[i,] <- out$return.matrix[,"nodes"]
}
colMeans(ret.mat)
for(i in 1:niter){
dat <- sim_regDat(500,100,30,c(.1,.1,.1))
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
ret.mat[i,] <- out$return.matrix[,"nodes"]
}
for(i in 1:niter){
dat <- sim_regDat(500,100,30,rep(.1,30))
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
ret.mat[i,] <- out$return.matrix[,"nodes"]
}
colMeans(ret.mat)
library(MASS) # for boston data
data(Boston)
rpart.Boston <- rpart::rpart(medv ~., data=Boston,weights=NULL)
plot(rpart.Boston);text(rpart.Boston)
ctree.Boston <- party::ctree(medv ~., data=Boston)
out <- dtree(medv ~., data=Boston)
out
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
out
for(i in 1:niter){
dat <- sim_regDat(500,100,30,rep(.4,30))
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
ret.mat[i,] <- out$return.matrix[,"nodes"]
}
ret.mat
dat
dat <- sim_regDat(500,10,0)
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
out
for(i in 1:niter){
#dat <- sim_regDat(500,10,0)
dat <- sim_regDat(500,100,30,rep(.8,30))
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
ret.mat[i,] <- out$return.matrix[,"nodes"]
}
ret.mat
str(dat)
dat <- sim_regDat(500,100,30,rep(.8,30))
cor(dat)
dat <- sim_regDat(500,10,3,rep(.3,3))
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
out
out <- dtree(y ~ ., data.matrix(dat),methods=c("rpart","ctree","evtree"))
out <- dtree(y ~ ., as.matrix(dat),methods=c("rpart","ctree","evtree"))
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
out
evtree(y ~ ., dat)
var(dat$y)
sim_regDat <- function(N,P,nonzero.num=NULL,beta.nonzero=NULL){
x=data.frame(matrix(rnorm(P*N),ncol=P))
if(is.null(nonzero.num)==TRUE){
beta <- rep(0,P)
}else{
beta <- c(beta.nonzero,rep(0,P-nonzero.num))
}
y <- as.matrix(x)%*%beta + rnorm(nrow(x),0,3)
return(data.frame(y,x))
}
dat <- sim_regDat(500,10,3,rep(.3,3))
out <- dtree(y ~ ., dat,methods=c("rpart","ctree","evtree"))
out
var(dat$y)
evtree(y ~ ., dat)
sim_regDat <- function(N,P,nonzero.num=NULL,beta.nonzero=NULL){
x=data.frame(matrix(rnorm(P*N),ncol=P))
if(is.null(nonzero.num)==TRUE){
beta <- rep(0,P)
}else{
beta <- c(beta.nonzero,rep(0,P-nonzero.num))
}
y <- as.matrix(x)%*%beta + rnorm(nrow(x),0,1)
return(data.frame(y,x))
}
sim_regDat <- function(N,P,nonzero.num=NULL,beta.nonzero=NULL){
x=data.frame(matrix(rnorm(P*N),ncol=P))
if(is.null(nonzero.num)==TRUE){
beta <- rep(0,P)
}else{
beta <- c(beta.nonzero,rep(0,P-nonzero.num))
}
y <- as.matrix(x)%*%beta + rnorm(nrow(x),0,1)
return(data.frame(y,x))
}
dat <- sim_regDat(500,10,3,c(1,1,1))
evtree(y ~ ., dat)
var(dat$y)
sim_regDat <- function(N,P,nonzero.num=NULL,beta.nonzero=NULL){
x=data.frame(matrix(rnorm(P*N),ncol=P))
if(is.null(nonzero.num)==TRUE){
beta <- rep(0,P)
}else{
beta <- c(beta.nonzero,rep(0,P-nonzero.num))
}
y <- as.matrix(x)%*%beta + rnorm(nrow(x),0,1)
return(data.frame(y,x))
}
dat <- sim_regDat(500,10,3,c(1,1,1))
evtree(y ~ ., dat)
