{
    "collab_server" : "",
    "contents" : "\nrpart_ret <- function(formula, data.train, data.test,samp.method,tuneLength,subset,class.response, response,Metric){\n\nret <- list()\n\nif(class.response == \"numeric\" | class.response == \"integer\"){\n  return.matrix <- matrix(NA,1,7)\n  colnames(return.matrix) <- c(\"nodes\",\"nvar\",\"nsplits\",\"rmse.samp\",\n                              \"rsq.samp\",\"rmse.test\",\"rsq.test\")\n  repeats <- ifelse(grepl(\"repeatedcv\", samp.method), 10, 1)\n  ctrl <- trainControl(method=samp.method,repeats=repeats)\n}else{\n  return.matrix <- matrix(NA,1,7)\n  colnames(return.matrix) <- c(\"nodes\",\"nvar\",\"nsplits\",\"auc.samp\",\n                               \"accuracy.samp\",\"auc.test\",\"accuracy.test\")\n\n  fiveStats <- function(...) c(twoClassSummary(...),\n                               + defaultSummary(...))\n  ## Everything but the area under the ROC curve:\n  fourStats <- function (data, lev = levels(data$obs), model = NULL)\n  {\n\n    accKapp<-postResample(data[,\"pred\"],data[,\"obs\"])\n    out<-c(accKapp,\n           sensitivity(data[, \"pred\"], data[, \"obs\"], lev[1]),\n           specificity(data[, \"pred\"], data[, \"obs\"], lev[2]))\n    names(out)[3:4]<-c(\"Sens\",\"Spec\")\n    out\n  }\n  repeats <- ifelse(grepl(\"repeatedcv\", samp.method), 10, 1)\n  ctrl <- trainControl(method=samp.method,classProbs=TRUE,summaryFunction = fiveStats,repeats=repeats)\n}\n\n#rpart.out <- rpart(formula,data.train)\n\n\ntrain.out <- train(formula,data.train,method=\"rpart\",tuneLength=tuneLength,\n                   trControl=ctrl,metric=Metric,na.action=na.pass)\nrpart.out <- train.out$finalModel\n\ncp <- rpart.out$cptable\nmin.error <- which(min(cp[,\"rel error\"]) == cp[,\"rel error\"])[1]\nreturn.matrix[1,\"nsplits\"] <- cp[min.error,\"nsplit\"]\n#train.out$varImp\n\n\n\n  rpart.ret <- rpart.out\n\n\n\nvars <- rpart.ret$frame[,\"var\"]\nvars2 <- vars[vars != \"<leaf>\"]\nreturn.matrix[1,\"nvar\"] <- length(unique(vars2))\n\nreturn.matrix[1,\"nodes\"] <- length(vars[vars == \"<leaf>\"])\n\nreturn.splits <- list()\n\nif(cp[min.error,\"nsplit\"] == 0){\n  return.splits <- as.data.frame(matrix(NA,1,2))\n  colnames(return.splits) <- c(\"var\",\"val\")\n  return.splits[1,1] <- \"no split\"\n  return.splits[1,2] <- 0\n  return.splits[1,1] <- as.character(return.splits[1,1])\n  return.splits[1,2] <- as.numeric(as.character(return.splits[1,2]))\n}else{\n  hh <- rpart.utils::rpart.subrules.table(rpart.out)\n\n  hh2 <- hh[is.na(hh$Less == FALSE),]\n  hh3 <- hh2[,c(\"Variable\",\"Value\")]\n  colnames(hh3) <- c(\"var\",\"val\")\n  hh3[,1] <- as.character(hh3[,1])\n  hh3[,2] <- round(as.numeric(as.character(hh3[,2])),3)\n  row.names(hh3) <- c()\n  return.splits <- hh3\n}\n\n\n\nind <- as.numeric(row.names(train.out$bestTune))\nif(class.response == \"numeric\" | class.response == \"integer\"){\n   #which(train.out$results[,\"cp\"] == train.out$bestTune)\n\n  return.matrix[1,\"rmse.samp\"] <- train.out$results[ind,\"RMSE\"]\n  #return.matrix[1,\"misfit.train\"] <- mean((data.train[,response] - predict(rpart.out))^2)/nrow(data.train)\n  return.matrix[1,\"rsq.samp\"] <- train.out$results[ind,\"Rsquared\"]\n\n      if(subset==FALSE){\n        return.matrix[1,\"rmse.test\"] <- NA\n        return.matrix[1,\"rsq.test\"] <- NA\n      }else{\n        return.matrix[1,\"rmse.test\"] <- mean((data.test[,response] -\n                                                  predict(rpart.out,data.test))^2)/nrow(data.test)\n        return.matrix[1,\"rsq.test\"] <- (cor(data.test[,response],predict(rpart.out,data.test)))**2\n      }\n}else{\n  return.matrix[1,\"auc.samp\"] <- train.out$results[ind,\"ROC\"]\n  return.matrix[1,\"accuracy.samp\"] <- train.out$results[ind,\"Accuracy\"]\n\n  if(subset==FALSE){\n    return.matrix[1,\"auc.test\"] <- NA\n  }else{\n    return.matrix[1,\"auc.test\"] <- NA\n  }\n}\n\nif(return.matrix[1,2] > 0){\n  rtree = rpart.utils::rpart.subrules.table(rpart.out)[1,2:5]\n  rtree2 <- matrix(rtree[is.na(rtree)==FALSE],1,2)\n  colnames(rtree2) <- c(\"var\",\"val\")\n  rtree2[,1] <- as.character(rtree2[,1])\n  rtree2[,2] <- round(as.numeric(as.character(rtree2[,2])),3)\n}else{\n  rtree2 <- c(\"no split\",0)\n}\n\nret$firstSplit <- rtree2\nret$return.splits <- return.splits\nret$vec <- return.matrix\nret$rpart.ret <- rpart.ret\nret$rpart.train <- train.out\nreturn(ret)\n\n}\n",
    "created" : 1491391016194.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1078866032",
    "id" : "E445508C",
    "lastKnownWriteTime" : 1491391345,
    "last_content_update" : 1491391345509,
    "path" : "~/GitHub/dtree/R/rpart_ret.R",
    "project_path" : "R/rpart_ret.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 11,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}