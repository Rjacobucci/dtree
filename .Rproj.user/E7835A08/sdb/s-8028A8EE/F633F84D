{
    "collab_server" : "",
    "contents" : "## FIXME: data in party\n##   - currently assumed to be a data.frame\n##   - potentially empty\n##   - the following are all assumed to work:\n##     dim(data), names(data)\n##     sapply(data, class), lapply(data, levels)\n##   - potentially these need to be modified if data/terms\n##     should be able to deal with data bases\n\nparty <- function(node, data, fitted = NULL, terms = NULL, names = NULL, info = NULL) {\n\n    stopifnot(inherits(node, \"partynode\"))\n    stopifnot(inherits(data, \"data.frame\"))\n    ### make sure all split variables are there \n    ids <- nodeids(node)[!nodeids(node) %in% nodeids(node, terminal = TRUE)]\n    varids <- unique(unlist(nodeapply(node, ids = ids, FUN = function(x) \n        varid_split(split_node(x)))))\n    stopifnot(varids %in% 1:ncol(data))\n    \n    if(!is.null(fitted)) {\n        stopifnot(inherits(fitted, \"data.frame\"))\n        stopifnot(nrow(data) == 0L | nrow(data) == nrow(fitted))\n        \n\t# try to provide default variable \"(fitted)\"\n\tif(nrow(data) > 0L) {\n          if(!(\"(fitted)\" %in% names(fitted))) \n            fitted[[\"(fitted)\"]] <- fitted_node(node, data = data)\n\t} else {\n\t  stopifnot(\"(fitted)\" == names(fitted)[1L])\n\t}\n\n        nt <- nodeids(node, terminal = TRUE)\n        stopifnot(all(fitted[[\"(fitted)\"]] %in% nt))\n\n        node <- as.partynode(node, from = 1L)\n        nt2 <- nodeids(node, terminal = TRUE)\n        fitted[[\"(fitted)\"]] <- nt2[match(fitted[[\"(fitted)\"]], nt)]\n    } else {\n        node <- as.partynode(node, from = 1L)\n\t# default \"(fitted)\"\n\tif(nrow(data) > 0L & missing(fitted)) \n          fitted <- data.frame(\"(fitted)\" = fitted_node(node, \n            data = data), check.names = FALSE)\n    }\n    \n    party <- list(node = node, data = data, fitted = fitted, \n                  terms = NULL, names = NULL, info = info)\n    class(party) <- \"party\"\n\n    if(!is.null(terms)) {\n        stopifnot(inherits(terms, \"terms\"))\n\tparty$terms <- terms\n    }\n\n    if (!is.null(names)) {\n        n <- length(nodeids(party, terminal = FALSE))\n        if (length(names) != n)\n            stop(\"invalid\", \" \", sQuote(\"names\"), \" \", \"argument\")\n        party$names <- names\n    }\n\n    party\n}\n\nlength.party <- function(x)\n    length(nodeids(x))\n\nnames.party <- function(x)\n    .names_party(x)\n\n\"names<-.party\" <- function(x, value) {\n     n <- length(nodeids(x, terminal = FALSE))\n     if (!is.null(value) && length(value) != n)\n         stop(\"invalid\", \" \", sQuote(\"names\"), \" \", \"argument\")\n     x$names <- value\n     x\n}\n\n.names_party <- function(party) {\n    names <- party$names\n    if (is.null(names))\n        names <- as.character(nodeids(party, terminal = FALSE))\n    names\n}\n\nnode_party <- function(party) {\n    stopifnot(inherits(party, \"party\"))\n    party$node\n}\n\nis.constparty <- function(party) {\n    stopifnot(inherits(party, \"party\"))\n    if (!is.null(party$fitted)) \n        return(all(c(\"(fitted)\", \"(response)\") %in% names(party$fitted)))\n    return(FALSE)\n}\n\nas.constparty <- function(obj, ...) {\n    if(!inherits(obj, \"party\")) obj <- as.party(obj)\n    if (!is.constparty(obj)) {\n        if(is.null(obj$fitted))\n\t  obj$fitted <- data.frame(\"(fitted)\" = predict(obj, type = \"node\"), check.names = FALSE)\n\tif(!(\"(fitted)\" %in% names(obj$fitted)))\n\t  obj$fitted[\"(fitted)\"] <- predict(obj, type = \"node\")\n\tif(!(\"(response)\" %in% names(obj$fitted)))\n\t  obj$fitted[\"(response)\"] <- model.response(model.frame(obj))\n\tif(!(\"(weights)\" %in% names(obj$fitted))) {\n\t  w <- model.weights(model.frame(obj))\n\t  if(is.null(w) && any(w != 1L)) obj$fitted[\"(weights)\"] <- w\n\t}\n    }\n    if (is.constparty(obj)) {\n        ret <- obj\n        class(ret) <- c(\"constparty\", class(obj))\n        return(ret)\n    }\n    stop(\"cannot coerce object of class\", \" \", sQuote(class(obj)), \n          \" \", \"to\", \" \", sQuote(\"constparty\"))\n}\n\n\"[.party\" <- \"[[.party\" <- function(x, i, ...) {\n    if (is.character(i) && !is.null(names(x)))\n        i <- which(names(x) %in% i)\n    stopifnot(length(i) == 1 & is.numeric(i))\n    stopifnot(i <= length(x) & i >= 1)\n    i <- as.integer(i)\n    dat <- data_party(x, i)\n    if (!is.null(x$fitted)) {\n        findx <- which(\"(fitted)\" == names(dat))[1]\n        fit <- dat[,findx:ncol(dat), drop = FALSE]\n        dat <- dat[,-(findx:ncol(dat)), drop = FALSE]\n        if (ncol(dat) == 0)\n            dat <- x$data\n    } else {\n        fit <- NULL\n        dat <- x$data\n    }\n    nam <- names(x)[nodeids(x, from = i, terminal = FALSE)]\n\n    recFun <- function(node) {\n        if (id_node(node) == i) return(node)\n        kid <- sapply(kids_node(node), id_node)\n        return(recFun(node[[max(which(kid <= i))]]))\n    }\n    node <- recFun(node_party(x))\n\n    ret <- party(node = node, data = dat, fitted = fit, \n                 terms = x$terms, names = nam, info = x$info)\n    class(ret) <- class(x)\n    ret\n}\n\nnodeids <- function(obj, ...)\n    UseMethod(\"nodeids\")\n\nnodeids.partynode <- function(obj, from = NULL, terminal = FALSE, ...) {\n\n    if(is.null(from)) from <- id_node(obj)\n\n    id <- function(node, record = TRUE, terminal = FALSE) {\n      if(!record) return(NULL)\n      if(!terminal)\n          return(id_node(node))\n      else\n          if(is.terminal(node)) return(id_node(node)) else return(NULL)\n    }\n\n    rid <- function(node, record = TRUE, terminal = FALSE) {  \n        myid <- id(node, record = record, terminal = terminal)\n        if(is.terminal(node)) return(myid)\n        kids <- kids_node(node)    \n        kids_record <- if(record)  \n            rep(TRUE, length(kids))\n        else\n            sapply(kids, id_node) == from\n        return(c(myid,\n            unlist(lapply(1:length(kids), function(i)\n                rid(kids[[i]], record = kids_record[i], terminal = terminal)))\n        ))\n    }\n\n    return(rid(obj, from == id_node(obj), terminal))\n}\n\nnodeids.party <- function(obj, from = NULL, terminal = FALSE, ...)\n    nodeids(node_party(obj), from = from, terminal = terminal, ...)\n\nnodeapply <- function(obj, ids = 1, FUN = NULL, ...)\n    UseMethod(\"nodeapply\")\n\nnodeapply.party <- function(obj, ids = 1, FUN = NULL, by_node = TRUE, ...) {\n\n    stopifnot(isTRUE(all.equal(ids, round(ids))))\n    ids <- as.integer(ids)\n\n    if(is.null(FUN)) FUN <- function(x, ...) x\n\n    if (length(ids) == 0)\n        return(NULL)\n\n    if (by_node) {\n        rval <- nodeapply(node_party(obj), ids = ids, FUN = FUN, ...)\n    } else {\n        rval <- lapply(ids, function(i) FUN(obj[[i]], ...))\n    }\n\n    names(rval) <- names(obj)[ids]\n    return(rval)\n}\n\nnodeapply.partynode <- function(obj, ids = 1, FUN = NULL, ...) {\n\n    stopifnot(isTRUE(all.equal(ids, round(ids))))\n    ids <- as.integer(ids)\n\n    if(is.null(FUN)) FUN <- function(x, ...) x\n\n    if (length(ids) == 0)\n        return(NULL)\n\n    rval <- vector(mode = \"list\", length = length(ids))\n    rval_id <- rep(0, length(ids))\n    i <- 1\n\t\n    recFUN <- function(node, ...) {\n        if(id_node(node) %in% ids) {\n            rval_id[i] <<- id_node(node)\n            rval[[i]] <<- FUN(node, ...)\n            i <<- i + 1\n        }\n        kids <- kids_node(node)\n        if(length(kids) > 0) {\n            for(j in 1:length(kids)) recFUN(kids[[j]])\n        }\n        invisible(TRUE)\n    }\n    foo <- recFUN(obj)\n    rval <- rval[match(rval_id, ids)]\n    return(rval)\n}\n\npredict.party <- function(object, newdata = NULL, perm = NULL, ...)\n{\n    ### compute fitted node ids first\n    fitted <- if(is.null(newdata)) {    \n        object$fitted[[\"(fitted)\"]]\t\n    } else {\n      terminal <- nodeids(object, terminal = TRUE)\n\t\n      if(max(terminal) == 1L) {\n        rep.int(1L, NROW(newdata))\n      } else {\n\t\n        inner <- 1L:max(terminal)\n        inner <- inner[-terminal]\n\n        primary_vars <- nodeapply(object, ids = inner, by_node = TRUE, FUN = function(node) {\n            varid_split(split_node(node))\n        })\n        surrogate_vars <- nodeapply(object, ids = inner, by_node = TRUE, FUN = function(node) {\n            surr <- surrogates_node(node)\n            if(is.null(surr)) return(NULL) else return(sapply(surr, varid_split))\n        })\n        vnames <- names(object$data)\n\n        ### the splits of nodes with a primary split in perm\n        ### will be permuted\n        if (!is.null(perm)) {\n            stopifnot(all(perm %in% vnames))\n            perm <- match(perm, vnames)\n        }\n\n        ## ## FIXME: the is.na() call takes loooong on large data sets\n        ## unames <- if(any(sapply(newdata, is.na))) \n        ##     vnames[unique(unlist(c(primary_vars, surrogate_vars)))]\n        ## else \n        ##     vnames[unique(unlist(primary_vars))]\n\tunames <- vnames[unique(unlist(c(primary_vars, surrogate_vars)))]\n\t\n        vclass <- structure(lapply(object$data, class), .Names = vnames)\n        ndnames <- names(newdata)\n        ndclass <- structure(lapply(newdata, class), .Names = ndnames)\n        checkclass <- all(sapply(unames, function(x) \n          isTRUE(all.equal(vclass[[x]], ndclass[[x]]))))\n        factors <- sapply(unames, function(x) inherits(object$data[[x]], \"factor\"))\n        checkfactors <- all(sapply(unames[factors], function(x) \n          isTRUE(all.equal(levels(object$data[[x]]), levels(newdata[[x]])))))\n        ## FIXME: inform about wrong classes / factor levels?\n        if(all(unames %in% ndnames) && checkclass && checkfactors) {\n            vmatch <- match(vnames, ndnames)\n            fitted_node(node_party(object), data = newdata, \n                        vmatch = vmatch, perm = perm)\n        } else {\n            if (!is.null(object$terms)) {\n                mf <- model.frame(delete.response(object$terms), newdata)\n                fitted_node(node_party(object), data = mf, \n                            vmatch = match(vnames, names(mf)), perm = perm)\n            } else\n                stop(\"\") ## FIXME: write error message\n        }\n      }\n    }\n    ### compute predictions\n    predict_party(object, fitted, newdata, ...)\n}\n\npredict_party <- function(party, id, newdata = NULL, ...)\n    UseMethod(\"predict_party\")\n\n### do nothing expect returning the fitted ids\npredict_party.default <- function(party, id, newdata = NULL, FUN = NULL, ...) {\n\n    if (length(list(...)) > 1) \n        warning(\"argument(s)\", \" \", sQuote(names(list(...))), \" \", \"have been ignored\")\n\n    ## get observation names: either node names or\n    ## observation names from newdata\n    nam <- if(is.null(newdata)) {\n      if(is.null(rnam <- rownames(data_party(party)))) names(party)[id] else rnam      \n    } else {\n      rownames(newdata)\n    }\n    if(length(nam) != length(id)) nam <- NULL\n\n    if (!is.null(FUN))\n        return(.simplify_pred(nodeapply(party, \n            nodeids(party, terminal = TRUE), FUN, by_node = TRUE), id, nam))\n\n    ## special case: fitted ids\n    return(structure(id, .Names = nam))\n}\n\npredict_party.constparty <- function(party, id, newdata = NULL,\n    type = c(\"response\", \"prob\", \"quantile\", \"density\", \"node\"),\n    at = if (type == \"quantile\") c(0.1, 0.5, 0.9),\n    FUN = NULL, simplify = TRUE, ...)\n{\n    ## extract fitted information\n    response <- party$fitted[[\"(response)\"]]\n    weights <- party$fitted[[\"(weights)\"]]\n    fitted <- party$fitted[[\"(fitted)\"]]\n    if (is.null(weights)) weights <- rep(1, NROW(response))\n\n    ## get observation names: either node names or\n    ## observation names from newdata\n    nam <- if(is.null(newdata)) names(party)[id] else rownames(newdata)\n    if(length(nam) != length(id)) nam <- NULL\n\n    ## match type\n    type <- match.arg(type)\n\n    ## special case: fitted ids\n    if(type == \"node\")\n      return(structure(id, .Names = nam))\n\n    ### multivariate response\n    if (is.data.frame(response)) {\n        ret <- lapply(response, function(r) {\n            ret <- .predict_party_constparty(node_party(party), fitted = fitted, \n                response = r, weights, id = id, type = type, at = at, FUN = FUN, ...)\n            if (simplify) .simplify_pred(ret, id, nam) else ret\n        })\n        if (all(sapply(ret, is.atomic)))\n            ret <- as.data.frame(ret)\n        names(ret) <- colnames(response)\n        return(ret)\n    }\n\n    ### univariate response\n    ret <- .predict_party_constparty(node_party(party), fitted = fitted, response = response, \n        weights = weights, id = id, type = type, at = at, FUN = FUN, ...)\n    if (simplify) .simplify_pred(ret, id, nam) else ret[as.character(id)]\n}\n\n### functions for node prediction based on fitted / response\n.pred_Surv <- function(y, w) {\n    if (length(y) == 0) return(NA)\n    survfit(y ~ 1, weights = w, subset = w > 0)\n}\n\n.pred_Surv_response <- function(y, w) {\n    if (length(y) == 0) return(NA)\n    .median_survival_time(.pred_Surv(y, w))\n}\n \n.pred_factor <- function(y, w) {\n    lev <- levels(y)\n    sumw <- tapply(w, y, sum)\n    sumw[is.na(sumw)] <- 0\n    prob <- sumw / sum(w)\n    names(prob) <- lev\n    return(prob)\n}\n\n.pred_factor_response <- function(y, w) {\n    prob <- .pred_factor(y, w)\n    return(factor(which.max(prob), levels = 1:nlevels(y),\n                  labels = levels(y), \n                  ordered = is.ordered(y)))\n    return(prob) \n}\n                    \n.pred_numeric_response <- function(y, w) \n    weighted.mean(y, w, na.rm = TRUE)\n\n.pred_ecdf <- function(y, w) {\n    if (length(y) == 0) return(NA)\n    iw <- as.integer(round(w))\n    if (max(abs(w - iw)) < sqrt(.Machine$double.eps)) {\n        y <- rep(y, w)\n        return(ecdf(y))\n    } else {\n        stop(\"cannot compute empirical distribution function with non-integer weights\")\n    }\n}\n\n.pred_quantile <- function(y, w) {\n    y <- rep(y, w)\n    function(p, ...) quantile(y, probs = p, ...)\n}\n\n.pred_density <- function(y, w) {\n    d <- density(y, weights = w / sum(w))\n    approxfun(d[1:2], rule = 2)\n}\n\n### workhorse: compute predictions based on fitted / response data\n.predict_party_constparty <- function(node, fitted, response, weights,\n    id = id, type = c(\"response\", \"prob\", \"quantile\", \"density\"),\n    at = if (type == \"quantile\") c(0.1, 0.5, 0.9), FUN = NULL, ...) {\n\n    type <- match.arg(type)\n    if (is.null(FUN)) {\n\n        rtype <- class(response)[1]\n        if (rtype == \"ordered\") rtype <- \"factor\"    \n        if (rtype == \"integer\") rtype <- \"numeric\"\n\n        if (type %in% c(\"quantile\", \"density\") && rtype != \"numeric\")\n            stop(\"quantile and density estimation currently only implemented for numeric responses\")\n\n        FUN <- switch(rtype,\n            \"Surv\" = if (type == \"response\") .pred_Surv_response else .pred_Surv,\n            \"factor\" = if (type == \"response\") .pred_factor_response else .pred_factor,\n            \"numeric\" = switch(type,\n                \"response\" = .pred_numeric_response,\n                \"prob\" = .pred_ecdf,\n                \"quantile\" = .pred_quantile, \n                \"density\" = .pred_density) \n       )\n    }\n      \n    ## empirical distribution in each leaf\n    if (all(id %in% fitted)) {\n        tab <- tapply(1:NROW(response), fitted, \n                      function(i) FUN(response[i], weights[i]), simplify = FALSE)\n    } else {\n        ### id may also refer to inner nodes\n        tab <- as.array(lapply(sort(unique(id)), function(i) {\n            index <- fitted %in% nodeids(node, i, terminal = TRUE)\n            ret <- FUN(response[index], weights[index])\n            ### no information about i in fitted\n            if (all(!index)) ret[1] <- NA\n            return(ret)\n        }))\n        names(tab) <- as.character(sort(unique(id)))\n    }\n    if (inherits(tab[[1]], \"function\") && !is.null(at))\n        tab <- lapply(tab, function(f) f(at))\n    tn <- names(tab)\n    dim(tab) <- NULL\n    names(tab) <- tn\n\n    tab\n}\n\n\n### simplify structure of predictions\n.simplify_pred <- function(tab, id, nam) {\n\n    if (all(sapply(tab, length) == 1) & all(sapply(tab, is.atomic))) {\n        ret <- do.call(\"c\", tab)\n        names(ret) <- names(tab)\n        ret <- if (is.factor(tab[[1]]))\n            factor(ret[as.character(id)], levels = 1:length(levels(tab[[1]])),\n\t\t   labels = levels(tab[[1]]), ordered = is.ordered(tab[[1]]))\n        else \n            ret[as.character(id)]\n        names(ret) <- nam\n    } else if (length(unique(sapply(tab, length))) == 1 & \n               all(sapply(tab, is.numeric))) {\n        ret <- matrix(unlist(tab), nrow = length(tab), byrow = TRUE)\n        colnames(ret) <- names(tab[[1]])\n        rownames(ret) <- names(tab)\n        ret <- ret[as.character(id),, drop = FALSE]\n        rownames(ret) <- nam\n    } else {\n        ret <- tab[as.character(id)]\n        names(ret) <- nam\n    }\n    ret\n}\n\ndata_party <- function(party, id = 1L)\n    UseMethod(\"data_party\")\n\ndata_party.default <- function(party, id = 1L) {\n    \n    extract <- function(id) {\n        if(is.null(party$fitted))\n            if(nrow(party$data) == 0) return(NULL)\n        else\n            stop(\"cannot subset data without fitted ids\")\n\n        ### which terminal nodes follow node number id?\n        nt <- nodeids(party, id, terminal = TRUE)\n        wi <- party$fitted[[\"(fitted)\"]] %in% nt\n\n        ret <- if (nrow(party$data) == 0)\n            subset(party$fitted, wi)\n        else\n            subset(cbind(party$data, party$fitted), wi)\n        ret\n    }\n    if (length(id) > 1)\n        return(lapply(id, extract))\n    else \n        return(extract(id))\n}\n\nwidth.party <- function(x, ...) {\n  width(node_party(x), ...)\n}\n\ndepth.party <- function(x, root = FALSE, ...) {\n  depth(node_party(x), root = root, ...)\n}\n\ngetCall.party <- function(x, ...) {\n  x$info$call\n}\n\nformula.party <- function(x, ...) {\n  x <- terms(x)\n  NextMethod()\n}\n\nmodel.frame.party <- function(formula, ...)\n{\n  mf <- formula$data\n  if(nrow(mf) > 0L) return(mf)\n\n  dots <- list(...)\n  nargs <- dots[match(c(\"data\", \"na.action\", \"subset\"), names(dots), 0L)]\n  mf <- getCall(formula)\n  mf <- mf[c(1L, match(c(\"formula\", \"data\", \"subset\", \"na.action\"), names(mf), 0L))]\n  mf$drop.unused.levels <- TRUE\n  mf[[1L]] <- quote(stats::model.frame)\n  mf[names(nargs)] <- nargs\n  if(is.null(env <- environment(terms(formula)))) env <- parent.frame()\n  eval(mf, env)\n}\n\n\nnodeprune <- function(x, ids, ...)\n    UseMethod(\"nodeprune\")\n\nnodeprune.party <- function(x, ids, ...) {\n\n    ### map names to nodeids\n    if (!is.numeric(ids))\n        ids <- match(ids, names(x))\n    stopifnot(ids %in% nodeids(x))\n\n    ### compute indices path to each node\n    ### to be pruned off\n    idxs <- lapply(ids, .get_path, obj = node_party(x))\n\n    ### [[.party is NOT [[.list\n    cls <- class(x)\n    x <- unclass(x)\n    ni <- which(names(x) == \"node\")\n\n    for (i in 1:length(idxs)) {\n    \n        idx <- c(ni, idxs[[i]])\n        ### check if we already pruned-off this node\n        tmp <- try(x[[idx]], silent = TRUE)\n        if (inherits(tmp, \"try-error\"))\n            next()\n\n        ### node ids of off-pruned daugther nodes\n        idrm <- nodeids(x[[idx]])[-1]\n\n        ### prune node by introducing a \"new\" terminal node\n        x[[idx]] <- partynode(id = id_node(x[[idx]]),\n                              info = info_node(x[[idx]]))\n\n        ### constparty only: make sure the node ids in\n        ### fitted are corrected\n        if (length(idrm) > 0) {\n             if(!is.null(x$fitted) && \n                 \"(fitted)\" %in% names(x$fitted)) {\n                     j <- x$fitted[[\"(fitted)\"]] %in% idrm\n                     x$fitted[[\"(fitted)\"]][j] <- ids[i]\n             }\n        }\n    }\n\n    ### reindex to 1:max(nodeid)\n    class(x) <- cls\n    nodeids(x) <- 1:length(nodeids(x))\n    return(x)\n}\n\nnodeprune.partynode <- function(x, ids, ...) {\n\n    stopifnot(ids %in% nodeids(x))\n\n    ### compute indices path to each node\n    ### to be pruned off\n    idxs <- lapply(ids, .get_path, obj = x)\n\n    ### [[.partynode is NOT [[.list\n    cls <- class(x)\n    x <- unclass(x)\n\n    for (i in 1:length(idxs)) {\n        ## path to be pruned\n        idx <- idxs[[i]]\n\tif(!is.null(idx)) {\n          ### check if we already pruned-off this node\n          tmp <- try(x[[idx]], silent = TRUE)\n          if(inherits(tmp, \"try-error\")) next()\n          ### prune node by introducing a \"new\" terminal node\n          x[[idx]] <- partynode(id = id_node(tmp), info = info_node(tmp))\n\t} else {\n\t  ## if idx path is NULL prune everything\n\t  x[2L:4L] <- NULL\n\t}\n    }\n\n    class(x) <- cls\n    return(as.partynode(x, from = 1L))\n}\n\nnodeprune.default <- function(x, ids, ...)\n    stop(\"No\", sQuote(\"nodeprune\"), \"method for class\", class(x), \"implemented\")\n\n.list.rules.party <- function(x, i = NULL, ...) {\n    if (is.null(i)) i <- nodeids(x, terminal = TRUE)\n    if (length(i) > 1) {\n        ret <- sapply(i, .list.rules.party, x = x)\n        names(ret) <- if (is.character(i)) i else names(x)[i]\n        return(ret)\n    }\n    if (is.character(i) && !is.null(names(x)))\n        i <- which(names(x) %in% i)\n    stopifnot(length(i) == 1 & is.numeric(i))\n    stopifnot(i <= length(x) & i >= 1)\n    i <- as.integer(i)\n    dat <- data_party(x, i)  \n    if (!is.null(x$fitted)) {\n        findx <- which(\"(fitted)\" == names(dat))[1]  \n        fit <- dat[,findx:ncol(dat), drop = FALSE]   \n        dat <- dat[,-(findx:ncol(dat)), drop = FALSE]\n        if (ncol(dat) == 0)\n            dat <- x$data\n    } else {\n        fit <- NULL  \n        dat <- x$data\n    }\n\n    rule <- c()\n\n    recFun <- function(node) {\n        if (id_node(node) == i) return(NULL)   \n        kid <- sapply(kids_node(node), id_node)\n        whichkid <- max(which(kid <= i))\n        split <- split_node(node)\n        ivar <- varid_split(split)\n        svar <- names(dat)[ivar]\n        index <- index_split(split)\n        if (is.factor(dat[, svar])) {\n            if (is.null(index)) \n                index <- ((1:nlevels(dat[, svar])) > breaks_split(split)) + 1\n            slevels <- levels(dat[, svar])[index == whichkid]\n            srule <- paste(svar, \" %in% c(\\\"\", \n                paste(slevels, collapse = \"\\\", \\\"\", sep = \"\"), \"\\\")\",\n                sep = \"\")\n        } else {\n            if (is.null(index)) index <- 1:length(kid)\n            breaks <- cbind(c(-Inf, breaks_split(split)), \n                            c(breaks_split(split), Inf))\n            sbreak <- breaks[index == whichkid,]\n            right <- right_split(split)\n            srule <- c()\n            if (is.finite(sbreak[1]))\n                srule <- c(srule, \n                    paste(svar, ifelse(right, \">\", \">=\"), sbreak[1]))\n            if (is.finite(sbreak[2]))\n                srule <- c(srule, \n                    paste(svar, ifelse(right, \"<=\", \"<\"), sbreak[2]))\n            srule <- paste(srule, collapse = \" & \")\n        }\n        rule <<- c(rule, srule)\n        return(recFun(node[[whichkid]]))\n    }\n    node <- recFun(node_party(x))\n    paste(rule, collapse = \" & \")\n}\n",
    "created" : 1490398876243.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3411195685",
    "id" : "F633F84D",
    "lastKnownWriteTime" : 1464352182,
    "last_content_update" : 1464352182,
    "path" : "C:/Users/RJacobucci/Desktop/partykit_1.1-1 (1)/partykit/R/party.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 13,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}