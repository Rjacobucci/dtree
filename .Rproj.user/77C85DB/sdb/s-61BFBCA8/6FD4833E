{
    "collab_server" : "",
    "contents" : "\nbump_ret <- function(formula, data.train, data.test,samp.method,tuneLength,subset,class.response, response,Metric,bump.rep){\n\n  ret <- list()\n\n  if(class.response == \"numeric\" | class.response == \"integer\"){\n    return.matrix <- matrix(NA,1,7)\n    colnames(return.matrix) <- c(\"nodes\",\"nvar\",\"nsplits\",\"rmse.samp\",\n                                 \"rsq.samp\",\"rmse.test\",\"rsq.test\")\n    repeats <- ifelse(grepl(\"repeatedcv\", samp.method), 10, 1)\n    ctrl <- trainControl(method=samp.method,repeats=repeats)\n  }else{\n    return.matrix <- matrix(NA,1,7)\n    colnames(return.matrix) <- c(\"nodes\",\"nvar\",\"nsplits\",\"auc.samp\",\n                                 \"accuracy.samp\",\"auc.test\",\"accuracy.test\")\n\n    fiveStats <- function(...) c(twoClassSummary(...),\n                                 + defaultSummary(...))\n    ## Everything but the area under the ROC curve:\n    fourStats <- function (data, lev = levels(data$obs), model = NULL)\n    {\n\n      accKapp<-postResample(data[,\"pred\"],data[,\"obs\"])\n      out<-c(accKapp,\n             sensitivity(data[, \"pred\"], data[, \"obs\"], lev[1]),\n             specificity(data[, \"pred\"], data[, \"obs\"], lev[2]))\n      names(out)[3:4]<-c(\"Sens\",\"Spec\")\n      out\n    }\n    repeats <- ifelse(grepl(\"repeatedcv\", samp.method), 10, 1)\n    ctrl <- trainControl(method=samp.method,classProbs=TRUE,summaryFunction = fiveStats,repeats=repeats)\n  }\n\n  #bump.out <- bump(formula,data.train)\n  bump.list <- list()\n  bump.matrix <- matrix(NA,bump.rep,7)\n  for(i in 1:bump.rep){\n    set.seed(i)\n    ids <- sample(nrow(data.train),nrow(data.train),replace=TRUE)\n    train.out <- train(formula,data.train[ids,],method=\"rpart\",tuneLength=tuneLength,\n                       trControl=ctrl,metric=Metric)\n    bump.list[[i]] <- train.out$finalModel\n    bump.out <- train.out$finalModel\n    bump.ret <- bump.out\n\n    cp <- bump.out$cptable\n    min.error <- which(min(cp[,\"rel error\"]) == cp[,\"rel error\"])[1]\n    return.matrix[1,\"nsplits\"] <- cp[min.error,\"nsplit\"]\n    #train.out$varImp\n\n\n    vars <- bump.ret$frame[,\"var\"]\n    vars2 <- vars[vars != \"<leaf>\"]\n    return.matrix[1,\"nvar\"] <- length(unique(vars2))\n\n    return.matrix[1,\"nodes\"] <- length(vars[vars == \"<leaf>\"])\n\n    return.splits <- list()\n\n    if(cp[min.error,\"nsplit\"] == 0){\n      return.splits <- NA\n    }else{\n      hh <- rpart.utils::rpart.subrules.table(bump.out)\n\n      hh2 <- hh[is.na(hh$Less == FALSE),]\n      hh3 <- hh2[,c(\"Variable\",\"Value\")]\n      colnames(hh3) <- c(\"var\",\"val\")\n      hh3[,1] <- as.character(hh3[,1])\n      hh3[,2] <- round(as.numeric(as.character(hh3[,2])),3)\n      row.names(hh3) <- c()\n      return.splits <- hh3\n    }\n\n\n\n    ind <- as.numeric(row.names(train.out$bestTune))\n    if(class.response == \"numeric\" | class.response == \"integer\"){\n      #which(train.out$results[,\"cp\"] == train.out$bestTune)\n\n      return.matrix[1,\"rmse.samp\"] <- train.out$results[ind,\"RMSE\"]\n      #return.matrix[1,\"misfit.train\"] <- mean((data.train[,response] - predict(bump.out))^2)/nrow(data.train)\n      return.matrix[1,\"rsq.samp\"] <- train.out$results[ind,\"Rsquared\"]\n\n      if(subset==FALSE){\n        return.matrix[1,\"rmse.test\"] <- NA\n        return.matrix[1,\"rsq.test\"] <- NA\n      }else{\n        return.matrix[1,\"rmse.test\"] <- mean((data.test[,response] -\n                                                predict(bump.out,data.test))^2)/nrow(data.test)\n        return.matrix[1,\"rsq.test\"] <- (cor(data.test[,response],predict(bump.out,data.test)))**2\n      }\n    }else{\n      return.matrix[1,\"auc.samp\"] <- train.out$results[ind,\"ROC\"]\n      return.matrix[1,\"accuracy.samp\"] <- train.out$results[ind,\"Accuracy\"]\n\n      if(subset==FALSE){\n        return.matrix[1,\"auc.test\"] <- NA\n      }else{\n        return.matrix[1,\"auc.test\"] <- NA\n      }\n    }\n    bump.matrix[i,] <- return.matrix\n    colnames(bump.matrix) <- colnames(return.matrix)\n\n  }\n\n\n\n\n\n  ret$bump.list <- bump.list\n  ret$bump.matrix <- bump.matrix\n  return(ret)\n\n}\n",
    "created" : 1490633590457.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1341913668",
    "id" : "6FD4833E",
    "lastKnownWriteTime" : 1490637968,
    "last_content_update" : 1490637968684,
    "path" : "~/GitHub/dtree/R/bump_ret.R",
    "project_path" : "R/bump_ret.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}