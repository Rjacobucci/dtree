{
    "collab_server" : "",
    "contents" : "\nctreePrune_ret <- function(formula,data.train,data.test,class.response,subset,response){\n\n\n  ret <- list()\n\n  if(class.response == \"numeric\" | class.response == \"integer\"){\n    return.matrix <- matrix(NA,1,7)\n    colnames(return.matrix) <- c(\"nodes\",\"nvar\",\"nsplits\",\"rmse.samp\",\n                                 \"rsq.samp\",\"rmse.test\",\"rsq.test\")\n  }else{\n    return.matrix <- matrix(NA,1,7)\n    colnames(return.matrix) <- c(\"nodes\",\"nvar\",\"nsplits\",\"auc.samp\",\n                                 \"accuracy.samp\",\"auc.test\",\"accuracy.test\")\n\n  }\n\n\n\n  out <- ctreePrune(formula=formula, data=data.train)\n  ctreePrune.out <- ctreePrune.ret <- out$tree\n\n  #min.error <- which(min(cp[,\"xerror\"]) == cp[,\"xerror\"])[1]\n  return.matrix[1,\"nsplits\"] <- max(fitted(ctreePrune.out)[,1]) - length(unique(fitted(ctreePrune.out)[,1]))\n  #return.matrix[1,\"fit.cv\"] <- cp[min.error,\"xerror\"]\n\n\n\n  #depth(ctreePrune.out$node)\n\n  ret.obj <- as.list(ctreePrune.out$node)\n  len <- length(ret.obj)\n\n  vars <- rep(NA,len)\n  for(i in 1:len){\n\n    if(is.null(ret.obj[[i]]$split$varid)==FALSE){\n      vars[i] <- ret.obj[[i]]$split$varid -1\n    }else{\n      vars[i] <- NA\n    }\n  }\n\n\n  breaks <- rep(NA,len)\n  for(i in 1:len){\n\n    if(is.null(ret.obj[[i]]$split$breaks)==FALSE){\n      breaks[i] <- ret.obj[[i]]$split$breaks\n    }else{\n      breaks[i] <- NA\n    }\n  }\n\n\n  return.splits <- list()\n\n  if(return.matrix[1,\"nsplits\"] == 0){\n    return.splits <- as.data.frame(matrix(NA,1,2))\n    colnames(return.splits) <- c(\"var\",\"val\")\n    return.splits[1,1] <- \"no split\"\n    return.splits[1,2] <- 0\n    return.splits[1,1] <- as.character(return.splits[1,1])\n    return.splits[1,2] <- as.numeric(as.character(return.splits[1,2]))\n  }else{\n    tt = terms(formula,data=data.train)\n    preds <- unlist(attr(tt,\"term.labels\"))\n\n    breaks2 <- breaks[complete.cases(breaks)]\n    vars2 <- vars[complete.cases(vars)]\n\n    return.splits <- data.frame(cbind(preds[vars2],breaks2))\n    colnames(return.splits) <- c(\"var\",\"val\")\n    return.splits[,2] <- as.numeric(as.character(return.splits[,2]))\n\n  }\n\n\n\n  vars2 <- vars[is.na(vars)==FALSE]\n  vars3 <- length(unique(vars2))\n\n  ctreePrune.ret <- ctreePrune.out\n  #attributes(ctreePrune.out)\n\n\n  return.matrix[1,\"nvar\"] <- vars3\n\n  return.matrix[1,\"nodes\"] <- length(unique(fitted(ctreePrune.out)[,1]))\n\n  met1 <- rep(NA,20)\n  met2 <- rep(NA,20)\n  for(i in 1:20){\n    set.seed(i)\n\n    ids1 <- sample(nrow(data.train),nrow(data.train),replace=TRUE)\n\n    train <- data.train[ids1,]\n    test <- data.train[-ids1,]\n\n    tt <- ctreePrune(formula=formula, data=train)\n\n    if(class.response == \"numeric\" | class.response == \"integer\"){\n      met1[i] <- sqrt(mean((test[,response] - predict(tt$tree,test))^2))\n      met2[i] <- (cor(test[,response],predict(tt$tree,test)))**2\n    }else{\n      if(all(duplicated(test[,response])[-1L])){\n        met1[i] <- NA\n      }else{\n        met1[i] <- pROC::auc(test[,response],predict(tt$tree,test,type=\"prob\")[,1])\n      }\n      met2[i] <- caret::confusionMatrix(test[,response],predict(tt$tree,test))$overall[\"Accuracy\"]\n      }\n\n  }\n\n\n\n\n\n  if(class.response == \"numeric\" | class.response == \"integer\"){\n    #which(train.out$results[,\"cp\"] == train.out$bestTune)\n\n    #return.matrix[1,\"rmse.samp\"] <- train.out$results[ind,\"RMSE\"]\n    return.matrix[1,\"rmse.samp\"] <- mean(met1) #sqrt(mean((data.train[,response] - predict(ctreePrune.out))^2))\n    return.matrix[1,\"rsq.samp\"] <- mean(met2) #(cor(data.train[,response],predict(ctreePrune.out)))**2\n   #return.matrix[1,\"rsq.samp\"] <- train.out$results[ind,\"Rsquared\"]\n\n    if(subset==FALSE){\n      return.matrix[1,\"rmse.test\"] <- NA\n      return.matrix[1,\"rsq.test\"] <- NA\n    }else{\n      return.matrix[1,\"rmse.test\"] <- sqrt(mean((data.test[,response] - predict(ctreePrune.out,data.test))^2))\n      return.matrix[1,\"rsq.test\"] <- (cor(data.test[,response],predict(ctreePrune.out,data.test)))**2\n    }\n  }else{\n    return.matrix[1,\"auc.samp\"] <- mean(met1,na.rm=TRUE)#pROC::auc(data.train[,response],predict(ctreePrune.out,type=\"prob\")[,1])\n    return.matrix[1,\"accuracy.samp\"] <- mean(met2)#caret::confusionMatrix(data.train[,response],predict(ctreePrune.out))$overall[\"Accuracy\"]\n\n    if(subset==FALSE){\n     # return.matrix[1,\"auc.test\"] <- NA\n    }else{\n    #  return.matrix[1,\"auc.test\"] <- NA\n    }\n  }\n\n\n\n\n  ret$return.splits <- return.splits\n  ret$firstSplit <- return.splits[1,]\n  ret$vec <- return.matrix\n  ret$ctreePrune.ret <- ctreePrune.ret\n  return(ret)\n}\n",
    "created" : 1490726091621.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1622388866",
    "id" : "350806B4",
    "lastKnownWriteTime" : 1490735769,
    "last_content_update" : 1490735769922,
    "path" : "~/GitHub/dtree/R/ctreePrune_ret.R",
    "project_path" : "R/ctreePrune_ret.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}