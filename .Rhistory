vars[i] <- ret.obj[[i]]$split$varid
}else{
vars[i] <- NA
}
}
vars2 <- vars[is.na(vars)==FALSE]
vars3 <- length(unique(vars2))
#attributes(ctree.out)
return.matrix[1,"nvar"] <- vars3
return.matrix[1,"nodes"] <- length(unique(fitted(ctree.out)[,1]))
if(class.response == "numeric" | class.response == "integer"){
return.matrix[1,"fit.test"] <- mean((data.test[,response] -
predict(ctree.out,data.test))^2)/nrow(data.test)
}else{
return.matrix[1,"fit.test"] <- NA
}
ret$vec <- return.matrix
ret$ctree.ret <- ctree.out
return(ret)
}
if(any(methods == "ctree")){
ret3 <- ctree_ret(formula, data.train,data.test, prune, class.response,response)
return.matrix["ctree",] <- ret3$vec
ret$ctree.out <- ret3$ctree.ret
}
ret3 <- ctree_ret(formula, data.train,data.test, prune, class.response,response)
fitted(ctree.out)
fitted(ctree.out)[,1]
fitted(ctree.out)[,1]
length(unique(party::fitted(ctree.out)[,1]))
length(unique(fitted(ctree.out)[,1]))
library(dtree)
ctree_ret <- function(formula, data.train, data.test,class.response, response){
ret <- list()
return.matrix <- matrix(NA,1,6)
colnames(return.matrix) <- c("nodes","nvar","nsplits","fit.cv","fit.train","fit.test")
ctree.out <- party::ctree(formula,data.train)
#min.error <- which(min(cp[,"xerror"]) == cp[,"xerror"])[1]
return.matrix[1,"nsplits"] <- max(fitted(ctree.out)[,1]) - length(unique(fitted(ctree.out)[,1]))
#return.matrix[1,"fit.cv"] <- cp[min.error,"xerror"]
preds <- predict(ctree.out)
return.matrix[1,"fit.train"] <- mean((data.train[,response] - preds)^2)/nrow(data.train)
#depth(ctree.out$node)
ret.obj <- as.list(ctree.out$node)
len <- length(ret.obj)
vars <- rep(NA,len)
for(i in 1:len){
if(is.null(ret.obj[[i]]$split$varid)==FALSE){
vars[i] <- ret.obj[[i]]$split$varid
}else{
vars[i] <- NA
}
}
vars2 <- vars[is.na(vars)==FALSE]
vars3 <- length(unique(vars2))
#attributes(ctree.out)
return.matrix[1,"nvar"] <- vars3
return.matrix[1,"nodes"] <- length(unique(fitted(ctree.out)[,1]))
if(class.response == "numeric" | class.response == "integer"){
return.matrix[1,"fit.test"] <- mean((data.test[,response] -
predict(ctree.out,data.test))^2)/nrow(data.test)
}else{
return.matrix[1,"fit.test"] <- NA
}
ret$vec <- return.matrix
ret$ctree.ret <- ctree.out
return(ret)
}
if(any(methods == "ctree")){
ret3 <- ctree_ret(formula, data.train,data.test, class.response,response)
return.matrix["ctree",] <- ret3$vec
ret$ctree.out <- ret3$ctree.ret
}
ctree.out$node
ctree_ret <- function(formula, data.train, data.test,class.response, response){
ret <- list()
return.matrix <- matrix(NA,1,6)
colnames(return.matrix) <- c("nodes","nvar","nsplits","fit.cv","fit.train","fit.test")
ctree.out <- party::ctree(formula,data.train)
library(party)
#min.error <- which(min(cp[,"xerror"]) == cp[,"xerror"])[1]
return.matrix[1,"nsplits"] <- max(fitted(ctree.out)[,1]) - length(unique(fitted(ctree.out)[,1]))
#return.matrix[1,"fit.cv"] <- cp[min.error,"xerror"]
preds <- predict(ctree.out)
return.matrix[1,"fit.train"] <- mean((data.train[,response] - preds)^2)/nrow(data.train)
#depth(ctree.out$node)
ret.obj <- as.list(ctree.out$node)
len <- length(ret.obj)
vars <- rep(NA,len)
for(i in 1:len){
if(is.null(ret.obj[[i]]$split$varid)==FALSE){
vars[i] <- ret.obj[[i]]$split$varid
}else{
vars[i] <- NA
}
}
vars2 <- vars[is.na(vars)==FALSE]
vars3 <- length(unique(vars2))
#attributes(ctree.out)
return.matrix[1,"nvar"] <- vars3
return.matrix[1,"nodes"] <- length(unique(fitted(ctree.out)[,1]))
if(class.response == "numeric" | class.response == "integer"){
return.matrix[1,"fit.test"] <- mean((data.test[,response] -
predict(ctree.out,data.test))^2)/nrow(data.test)
}else{
return.matrix[1,"fit.test"] <- NA
}
ret$vec <- return.matrix
ret$ctree.ret <- ctree.out
return(ret)
}
if(any(methods == "ctree")){
ret3 <- ctree_ret(formula, data.train,data.test, class.response,response)
return.matrix["ctree",] <- ret3$vec
ret$ctree.out <- ret3$ctree.ret
}
ret$vec <- return.matrix
ret$rpart.ret <- tree1
ret$vec <- return.matrix
ret$ctree.ret <- ctree.out
formula
data.train
data.test
class.response
response
library(dtree)
out <- dtree(medv ~., data=Boston)
library(MASS) # for boston data
data(Boston)
formula = medv ~ .
methods=c("rpart","tree","ctree","evtree")
perc.sub=.5
ret <- list()
return.matrix <- matrix(NA,length(methods),6)
rownames(return.matrix) <- methods
colnames(return.matrix) <- c("nodes","nvar","nsplits","fit.cv","fit.train","fit.test")
ids <- sample(nrow(data),nrow(data)*perc.sub)
data.train <- data[ids,]
data=Boston
ids <- sample(nrow(data),nrow(data)*perc.sub)
data.train <- data[ids,]
data.test <- data[-ids,]
# parse out the response variable name
getResponseFormula <- function (object)
{
if (!(inherits(form, "formula") && (length(form) == 3))) {
form <- formula(object)
stop("'form' must be a two-sided formula")
}
eval(parse(text = paste("~", deparse(form[[2]]))))
}
response <- attr(terms(getResponseFormula(formula)),"term.labels")
# ------------------------------------------------------------------
class.response <- class(data.train[,response])
getResponseFormula <- function (object)
{
form <- formula(object)
if (!(inherits(form, "formula") && (length(form) == 3))) {
stop("'form' must be a two-sided formula")
}
eval(parse(text = paste("~", deparse(form[[2]]))))
}
response <- attr(terms(getResponseFormula(formula)),"term.labels")
# ------------------------------------------------------------------
class.response <- class(data.train[,response])
ret3 <- ctree_ret(formula, data.train,data.test, class.response,response)
ret <- list()
return.matrix <- matrix(NA,1,6)
colnames(return.matrix) <- c("nodes","nvar","nsplits","fit.cv","fit.train","fit.test")
ctree.out <- ctree(formula,data.train)
#min.error <- which(min(cp[,"xerror"]) == cp[,"xerror"])[1]
return.matrix[1,"nsplits"] <- max(fitted(ctree.out)[,1]) - length(unique(fitted(ctree.out)[,1]))
max(fitted(ctree.out)[,1]) - length(unique(fitted(ctree.out)[,1]))
fitted(ctree.out)
ctree.out
fitted(ctree.out)
ctree.out$fitted
str(ctree.out)
partykit::fitted(ctree.out)
partykit::fitted_node(ctree.out)
node(ctree.out)
ctree.out@responses
ctree.out@tree
as.list(ctree.out$node)
ret.obj <- as.list(ctree.out$tree)
ret.obj <- as.list(ctree.out@tree)
ret.obj
len <- length(ret.obj)
len
as.list(ctree.out@tree)
fitted(ctree.out)
ctree.out@fitted
ctree.out@get_where()
plot(ctree.out)
nodes <- ctree.out@get_where()
max(nodes)
tables(nodes)
table(nodes)
max(nodes) - length(unique(nodes))
nodes <- ctree.out@get_where()
return.matrix[1,"nsplits"] <- max(nodes) - length(unique(nodes))
#return.matrix[1,"fit.cv"] <- cp[min.error,"xerror"]
preds <- predict(ctree.out)
return.matrix[1,"fit.train"] <- mean((data.train[,response] - preds)^2)/nrow(data.train)
ctree.out@update()
ctree.out@cond_distr_response()
ctree.out@tree
str(ctree.out@tree)
nodes
ctree.out@prediction_weights(
)
ctree.out@data
summary(ctree.out)
ctree.out@tree
as.list(ctree.out@tree)
coef(ctree.out)
attributes(ctree.out)
ctree.out$tree
str(attributes(ctree.out))
ctree.out@tree@SplittingNode
attributes(ctree.out)
where(ctree.out)
treeresponse(ctree.out)
nodes(ctree.out)
nodes(ctree.out,1)
nodes(ctree.out,4)
str(nodes(ctree.out,4))
nodes(ctree.out,4)$psplit$variablename
nodes(ctree.out,4)@psplit@variablename
nodes(ctree.out,4)$psplit
nodes(ctree.out,4)[[psplit]]
nodes(ctree.out,4)[["psplit"]]
nodes(ctree.out,4)[[1]]$psplit
nodes(ctree.out,4)[[1]]$psplit$variablename
nodes(ctree.out,4)[[1]]$psplit$variableName
ctree.out@nodes
var.name <- rep(NA,max(nodes))
for(i in 1:max(nodes)){
var.name[i] <- nodes(ctree.out,4)[[1]]$psplit$variableName
}
var.name
var.name <- rep(NA,max(nodes))
for(i in 1:max(nodes)){
var.name[i] <- nodes(ctree.out,i)[[1]]$psplit$variableName
}
var.name
nodes(ctree.out,5)[[1]]$psplit$variableName
nodes(ctree.out,7)[[1]]$psplit$variableName
nodes
unique(nodes)
unique(nodes) !%in% 1:max(nodes)
unique(nodes) %in% 1:max(nodes)
subset(1:max(nodes), !(1:max(nodes) %in% unique(nodes)))
node.try <- subset(1:max(nodes), !(1:max(nodes) %in% unique(nodes)))
var.name <- rep(NA,length(node.try))
for(i in 1:max(nodes)){
var.name[i] <- nodes(ctree.out,node.try[i])[[1]]$psplit$variableName
}
node.try
var.name
var.name <- rep(NA,length(node.try))
var.name
max(nodes)
var.name <- rep(NA,length(node.try))
for(i in 1:length(var.name{
var.name[i] <- nodes(ctree.out,node.try[i])[[1]]$psplit$variableName
var.name <- rep(NA,length(node.try))
for(i in 1:length(var.name)){
var.name[i] <- nodes(ctree.out,node.try[i])[[1]]$psplit$variableName
}
var.name
length(unique(var.name))
out <- dtree(medv ~., data=Boston)
library(dtree)
out <- dtree(medv ~., data=Boston)
library(dtree)
out <- dtree(medv ~., data=Boston)
summary(out)
ret <- list()
return.matrix <- matrix(NA,1,6)
colnames(return.matrix) <- c("nodes","nvar","nsplits","fit.cv","fit.train","fit.test")
evtree.out <- evtree(formula,data.train)
#min.error <- which(min(cp[,"xerror"]) == cp[,"xerror"])[1]
return.matrix[1,"nsplits"] <- max(fitted(evtree.out)[,1]) - length(unique(fitted(evtree.out)[,1]))
#return.matrix[1,"fit.cv"] <- cp[min.error,"xerror"]
return.matrix[1,"fit.train"] <- mean((data.train[,response] - predict(evtree.out))^2)/nrow(data.train)
#depth(evtree.out$node)
ret.obj <- as.list(evtree.out$node)
len <- length(ret.obj)
vars <- rep(NA,len)
for(i in 1:len){
if(is.null(ret.obj[[i]]$split$varid)==FALSE){
vars[i] <- ret.obj[[i]]$split$varid
}else{
vars[i] <- NA
}
}
vars2 <- vars[is.na(vars)==FALSE]
vars3 <- length(unique(vars2))
#attributes(evtree.out)
return.matrix[1,"nvar"] <- vars3
return.matrix[1,"nodes"] <- length(unique(fitted(evtree.out)[,1]))
if(class.response == "numeric" | class.response == "integer"){
return.matrix[1,"fit.test"] <- mean((data.test[,response] -
predict(evtree.out,data.test))^2)/nrow(data.test)
}else{
return.matrix[1,"fit.test"] <- NA
}
return.matrix
library(dtree)
out <- dtree(medv ~., data=Boston)
summary(out)
library(MASS) # for boston data
data(Boston)
formula= medv ~ .,
formula= medv ~ .
data=Boston
methods=c("rpart","tree","ctree","evtree")
perc.sub=.5
ret <- list()
return.matrix <- matrix(NA,length(methods),6)
rownames(return.matrix) <- methods
colnames(return.matrix) <- c("nodes","nvar","nsplits","fit.cv","fit.train","fit.test")
ids <- sample(nrow(data),nrow(data)*perc.sub)
data.train <- data[ids,]
data.test <- data[-ids,]
if(any(methods == "evtree")){
ret4 <- evtree_ret(formula, data.train,data.test, class.response,response)
return.matrix["evtree",] <- ret4$vec
ret$evtree.out <- ret4$evtree.ret
}
ret <- list()
return.matrix <- matrix(NA,1,6)
colnames(return.matrix) <- c("nodes","nvar","nsplits","fit.cv","fit.train","fit.test")
evtree.out <- evtree(formula,data.train)
#min.error <- which(min(cp[,"xerror"]) == cp[,"xerror"])[1]
return.matrix[1,"nsplits"] <- max(fitted(evtree.out)[,1]) - length(unique(fitted(evtree.out)[,1]))
#return.matrix[1,"fit.cv"] <- cp[min.error,"xerror"]
return.matrix[1,"fit.train"] <- mean((data.train[,response] - predict(evtree.out))^2)/nrow(data.train)
#depth(evtree.out$node)
ret.obj <- as.list(evtree.out$node)
len <- length(ret.obj)
vars <- rep(NA,len)
for(i in 1:len){
if(is.null(ret.obj[[i]]$split$varid)==FALSE){
vars[i] <- ret.obj[[i]]$split$varid
}else{
vars[i] <- NA
}
}
vars2 <- vars[is.na(vars)==FALSE]
vars3 <- length(unique(vars2))
#attributes(evtree.out)
return.matrix[1,"nvar"] <- vars3
return.matrix[1,"nodes"] <- length(unique(fitted(evtree.out)[,1]))
if(class.response == "numeric" | class.response == "integer"){
return.matrix[1,"fit.test"] <- mean((data.test[,response] -
predict(evtree.out,data.test))^2)/nrow(data.test)
}else{
return.matrix[1,"fit.test"] <- NA
}
return.matrix
return.matrix[1,"nsplits"] <- max(fitted(evtree.out)[,1]) - length(unique(fitted(evtree.out)[,1]))
#return.matrix[1,"fit.cv"] <- cp[min.error,"xerror"]
return.matrix[1,"fit.train"] <- mean((data.train[,response] - predict(evtree.out))^2)/nrow(data.train)
predict(evtree.out)
data.train[,response]
getResponseFormula <- function (object)
{
form <- formula(object)
if (!(inherits(form, "formula") && (length(form) == 3))) {
stop("'form' must be a two-sided formula")
}
eval(parse(text = paste("~", deparse(form[[2]]))))
}
response <- attr(terms(getResponseFormula(formula)),"term.labels")
# ------------------------------------------------------------------
class.response <- class(data.train[,response])
#min.error <- which(min(cp[,"xerror"]) == cp[,"xerror"])[1]
return.matrix[1,"nsplits"] <- max(fitted(evtree.out)[,1]) - length(unique(fitted(evtree.out)[,1]))
#return.matrix[1,"fit.cv"] <- cp[min.error,"xerror"]
return.matrix[1,"fit.train"] <- mean((data.train[,response] - predict(evtree.out))^2)/nrow(data.train)
#depth(evtree.out$node)
ret.obj <- as.list(evtree.out$node)
len <- length(ret.obj)
vars <- rep(NA,len)
for(i in 1:len){
if(is.null(ret.obj[[i]]$split$varid)==FALSE){
vars[i] <- ret.obj[[i]]$split$varid
}else{
vars[i] <- NA
}
}
vars2 <- vars[is.na(vars)==FALSE]
vars3 <- length(unique(vars2))
#attributes(evtree.out)
return.matrix[1,"nvar"] <- vars3
return.matrix[1,"nodes"] <- length(unique(fitted(evtree.out)[,1]))
if(class.response == "numeric" | class.response == "integer"){
return.matrix[1,"fit.test"] <- mean((data.test[,response] -
predict(evtree.out,data.test))^2)/nrow(data.test)
}else{
return.matrix[1,"fit.test"] <- NA
}
return.matrix
evtree_ret <- function(formula, data.train, data.test, prune, class.response, response){
ret <- list()
return.matrix <- matrix(NA,1,6)
colnames(return.matrix) <- c("nodes","nvar","nsplits","fit.cv","fit.train","fit.test")
evtree.out <- evtree(formula,data.train)
#min.error <- which(min(cp[,"xerror"]) == cp[,"xerror"])[1]
return.matrix[1,"nsplits"] <- max(fitted(evtree.out)[,1]) - length(unique(fitted(evtree.out)[,1]))
#return.matrix[1,"fit.cv"] <- cp[min.error,"xerror"]
return.matrix[1,"fit.train"] <- mean((data.train[,response] - predict(evtree.out))^2)/nrow(data.train)
#depth(evtree.out$node)
ret.obj <- as.list(evtree.out$node)
len <- length(ret.obj)
vars <- rep(NA,len)
for(i in 1:len){
if(is.null(ret.obj[[i]]$split$varid)==FALSE){
vars[i] <- ret.obj[[i]]$split$varid
}else{
vars[i] <- NA
}
}
vars2 <- vars[is.na(vars)==FALSE]
vars3 <- length(unique(vars2))
#attributes(evtree.out)
return.matrix[1,"nvar"] <- vars3
return.matrix[1,"nodes"] <- length(unique(fitted(evtree.out)[,1]))
if(class.response == "numeric" | class.response == "integer"){
return.matrix[1,"fit.test"] <- mean((data.test[,response] -
predict(evtree.out,data.test))^2)/nrow(data.test)
}else{
return.matrix[1,"fit.test"] <- NA
}
ret$vec <- return.matrix
ret$evtree.ret <- evtree.out
return(ret)
}
ret4 <- evtree_ret(formula, data.train,data.test, class.response,response)
ret4
mean((data.test[,response] -
predict(evtree.out,data.test))^2)/nrow(data.test)
return.matrix
evtree_ret <- function(formula, data.train, data.test,class.response, response){
ret <- list()
return.matrix <- matrix(NA,1,6)
colnames(return.matrix) <- c("nodes","nvar","nsplits","fit.cv","fit.train","fit.test")
evtree.out <- evtree(formula,data.train)
#min.error <- which(min(cp[,"xerror"]) == cp[,"xerror"])[1]
return.matrix[1,"nsplits"] <- max(fitted(evtree.out)[,1]) - length(unique(fitted(evtree.out)[,1]))
#return.matrix[1,"fit.cv"] <- cp[min.error,"xerror"]
return.matrix[1,"fit.train"] <- mean((data.train[,response] - predict(evtree.out))^2)/nrow(data.train)
#depth(evtree.out$node)
ret.obj <- as.list(evtree.out$node)
len <- length(ret.obj)
vars <- rep(NA,len)
for(i in 1:len){
if(is.null(ret.obj[[i]]$split$varid)==FALSE){
vars[i] <- ret.obj[[i]]$split$varid
}else{
vars[i] <- NA
}
}
vars2 <- vars[is.na(vars)==FALSE]
vars3 <- length(unique(vars2))
#attributes(evtree.out)
return.matrix[1,"nvar"] <- vars3
return.matrix[1,"nodes"] <- length(unique(fitted(evtree.out)[,1]))
if(class.response == "numeric" | class.response == "integer"){
return.matrix[1,"fit.test"] <- mean((data.test[,response] -
predict(evtree.out,data.test))^2)/nrow(data.test)
}else{
return.matrix[1,"fit.test"] <- NA
}
ret$vec <- return.matrix
ret$evtree.ret <- evtree.out
return(ret)
}
ret4 <- evtree_ret(formula, data.train,data.test, class.response,response)
ret4
library(dtree)
out <- dtree(medv ~., data=Boston)
summary(out)
library(dtree)
library(dtree)
data
ret <- list()
return.matrix <- matrix(NA,1,6)
colnames(return.matrix) <- c("nodes","nvar","nsplits","misfit.cv","misfit.train","rsq.train","misfit.test","rsq.test")
evtree.out <- evtree(formula,data.train)
return.matrix <- matrix(NA,1,9)
colnames(return.matrix) <- c("nodes","nvar","nsplits","misfit.cv","misfit.train","rsq.train","misfit.test","rsq.test")
length(c("nodes","nvar","nsplits","misfit.cv","misfit.train","rsq.train","misfit.test","rsq.test"))
return.matrix <- matrix(NA,1,8)
colnames(return.matrix) <- c("nodes","nvar","nsplits","misfit.cv","misfit.train","rsq.train","misfit.test","rsq.test")
evtree.out <- evtree(formula,data.train)
return.matrix[1,"misfit.train"] <- mean((data.train[,response] - predict(evtree.out))^2)/nrow(data.train)
return.matrix[1,"misfit.test"] <- mean((data.test[,response] -
predict(evtree.out,data.test))^2)/nrow(data.test)
return.matrix[1,"rsq.train"] <- (cor(data.train[,response],predict(evtree.out)))**2
return.matrix[1,"rsq.test"] <- (cor(data.test[,response],predict(evtree.out,data.test)))**2
return.matrix
library(dtree)
out <- dtree(medv ~., data=Boston)
traceback()
library(dtree)
out <- dtree(medv ~., data=Boston)
library(dtree)
out <- dtree(medv ~., data=Boston)
summary(out)
